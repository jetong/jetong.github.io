Best practices
Title pages, use alt for images, web internationalization
<meta charset="utf-i"/>
<html lang="fr">
"type" attribute in link and script tags are optional

for accessibility and portability, split page content into regions using aside, footer, header, main, nav.
<section>
   <article>
     <header>
       Heading
     </header>
     <p>
       Some content.
       Some content.
       Some content.
     </p>
     <figure>
       <img src="some_pic.png" alt="some picture" />
         <figcaption>
             Fig. 1 : some pic... 
         </figcaption>
     </figure>
   <article>
    ...
   </article>
<section>
<!---------------------------------------->
<!-- FlexBox -->
<!-- associate an element with the 'flex-container' css class, then 
     its child elements automatically become flexible items. --> 
<!DOCTYPE html>
<html>
<head>
<style>
.flex-container {
  display: flex;
  background-color: Blue;
}

.flex-container > div {
  background-color: #11f1f1;
  margin: 10px;
  padding: 20px;
  font-size: 30px;
  width:30%;
}
</style>
</head>

<body>
<div class="flex-container">
  <div>1</div>
  <div>2</div>
  <div>3</div>  
</div>
</body>
</html>

<!---------------------------------------->
<!-- details & summary tags to create simple widget to hide/show contents -->
<!-- The summary element is not supported in Edge/Internet Explorer -->
<details>
  <summary>Copyright 1999-2014.</summary>
  <p> - by Refsnes Data. All Rights Reserved.</p>
</details>

<!-- css to format details & summary -->
summary::-webkit-details-marker {
 color:#FF0000; 
 background:#FFFFFF; 
}

details[open] summary::-webkit-details-marker {
	color:#0000FF;
	background:#00FFFF;
}

<!---------------------------------------->
polyfills - fallback javascript code that emulates an HTML5 feature not yet implemented certain browsers
http://caniuse.com
http://html5please.com
modernizr on github
Search for the particular HTML5 feature to see browser support and check for fallback script in resources tab

<!---------------------------------------->
<time> tag for flexibility in outputing various date formats for readers while making it 
easier for programs to index date data and allowing search engines and other programs to 
quickly locate and parse them.

<!---------------------------------------->
<mark> for highlighting text

<!---------------------------------------->
Download attribute.
<a href="https://www.somewhere.com/picture.gif" download="pic.gif">Download Picture</a>
Enables ability to force a download rather than navigating to the file.  Downloaded filename can be specified as well.

<!---------------------------------------->
Translate attribute.
<span translate="no">Linda</span>
Prevent/limit the impact of translation tools such as Google Translate.
This person's name would otherwise be translated into "Pretty" in Spanish.
Any children of the attributed elemented will also inherit the attribute.

<!-- Video embedding -->
Old way:
<object width="425" height="344">
   <param name="movie"
          value="http://www.youtube.com/v/9sEI1AUFJKw&hl=en_GB&fs=1&">
   </param>
   <param name="allowFullScreen"   value="true"></param>
   <param name="allowscriptaccess" value="always"></param>
   <embed src="http://www.youtube.com/v/9sEI1AUFJKw&hl=en_GB&fs=1&"
          type="application/x-shockwave-flash"
          allowscriptaccess="always" allowfullscreen="true"
          width="425" height="344">
   </embed>
</object>

HTML5
<!-- <video> tag, with the @controls attribute giving it the play/pause/seeker controls. 
     autoplay or loop, and can style using css since <video> is part ot the DOM -->
<video id="vid" controls autoplay> 
	<!-- I have three versions of the video encoded with
	     different codecs.  The browser will automatically
	     choose the first one it knows it can play. --> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.webm type=video/webm> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.ogg type=video/ogg> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.mp4 type=video/mp4> 
</video> 
<button onclick="playVideo();" style="cursor: pointer;">Play</button>
<button onclick="pauseVideo();" style="cursor: pointer;">Pause</button>
<button onclick="rewindVideo();" style="cursor: pointer;">Back to beginning</button>
<script>
  vid = document.querySelector("#vid");
  function playVideo() { vid.play(); }
  function pauseVideo() { vid.pause(); }
  function rewindVideo() { vid.currentTime = 0; }
</script>
<!-- That's it!  You now have video playing in your browser! -->

CSS for fullscreen video
body {
  margin:0;
  padding:0;
  overflow:hidden;
}
 
video {
  width:100%;
  height:auto;
}

To detect end of video and do something else (like play another video), listen for 'ended' event
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Sequential Movies</title>
    <script>
      var myVideo;
      var currentVideo = 0;
      var sources = [
        "https://mainline.i3s.unice.fr/mooc/samuraiPizzacat.mp4",
        "http://www.archive.org/download/AnimatedMechanicalArtPiecesAtMit/P1120973_512kb.mp4"
        ];
      // Set the src of the video to the next URL in the playlist
      function loadNextVideo() {
        myVideo.src = sources[currentVideo % sources.length]
        myVideo.load();
        currentVideo++;
      }
      // called by addEventListener
      function loadAndplayNextVideo() {
        console.log("playing " + sources[currentVideo % sources.length])
        loadNextVideo();
        myVideo.play();
      }
      function init(){
        myVideo = document.querySelector("#myVideo");
        // Define a callback function called each time a video ended
        myVideo.addEventListener('ended', loadAndplayNextVideo, false);
        // Load the first video when the page is loaded.
        loadNextVideo();
      }
    </script>
  </head>
<body onload="init()">
    <video id="myVideo"
      controls>
    </video>
</body>
</html>

For YouTube, Dailymotion, Vimeo, etc, need to embed differently:
(right click on video and select 'copy embed code')
(licensing and royalties prevent certain videos from playing)
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZH1XOsv8Oyo" frameborder="0" allowfullscreen></iframe>

<!-- Audio -->
<audio controls="controls">
   <source src="https://mainline.i3s.unice.fr/mooc/horse.ogg" type="audio/ogg" />
   <source src="https://mainline.i3s.unice.fr/mooc/horse.mp3" type="audio/mp3" />
      Your browser does not support the audio element.
      Download the audio/video in
   <a href="https://mainline.i3s.unice.fr/mooc/horse.ogg">OGG</a>
   or <a href="https://mainline.i3s.unice.fr/mooc/horse.mp3">MP3</a>
   format.
</audio>

Example using CSS3 transformations on video: https://jsbin.com/lunosev/1/edit?html,css,js,output

Example using filters in real time: https://jsbin.com/siduxad/edit?html,output

Example handling video errors and logs: https://jsbin.com/becaref/3/edit?html,output

Example displaying buffer progress indicator: https://jsbin.com/xororol/3/edit?html,output

Adding closed captions and subtitles using <track>:
http://www.universalsubtitles.org, also known as http://www.amara.org.  Allow uploading
YouTube video and offers online editor.

<!-- Graphics using <canvas> -->
Ensure page is loaded before running js either:
<body onload="init();">
or
in script, use window.onload = function() { get canvas object, etc };
or
place <script></script> tags at the very end
or
use defer

Steps:
1.  Declare the canvas, remembering to add an id attribute, and fallback content:  
<canvas id="myCanvas" width="200" height="200">
...fallback content...
</canvas>
2.  Get a reference to the canvas in a JavaScript variable using the DOM API: 
    var canvas=document.getElementById('myCanvas');
3.  Get the context for drawing in that canvas:  
    var ctx=canvas.getContext('2d');
4.  Specify some drawing properties (optional):  
    ctx.fillStyle='#FF0000';
5.  Draw some shapes: 
    ctx.fillRect(0,0,80,100);

Example
<!DOCTYPE html>
<html lang="en">
 <head>
   <title>Drawing principales unit√©</title>
  <meta charset="utf-8"/>
 <style>
     #myCanvas {
         border: 1px solid black;
     }
 </style>
 <script>
   var canvas, ctx;
 
   function init() {
     // 1 - Get the canvas
     canvas = document.getElementById('myCanvas');
     // 2 - Get the context
     ctx=canvas.getContext('2d');

     // Optionally do transformations to the context before drawing
     ctx.translate(100, 100);
     ctx.rotate(Math.PI/4);
     ctx.scale(0.5, 0.5);

     // 3 - we can draw
     drawSomething();
   }
   function drawSomething() {
     // draw a red rectangle, line width=3 pixels
     ctx.lineWidth=3;
     ctx.strokeStyle='red';
     ctx.strokeRect(10,10,80,100);
   }
 </script>
 </head>
<body onload="init();">
    <canvas id="myCanvas" width="200" height="200">
            Your browser does not support the canvas tag.
    </canvas>
</body>
</html>

There are two methods for saving and restoring the context properties: ctx.save()and ctx.restore().
Best practice: save the context at the beginning of any function 
that changes the context, restore it at the end of the function!

To draw an image from a file source, make sure web page loaded, and make sure image is loaded in memory first:
<script>
  // wait for page to load
  window.onload = function () {
    var canvas = document.getElementById("myCanvas");
    var context = canvas.getContext("2d");
    var imageObj = new Image();
    // wait for image to load into memory before drawing
    imageObj.onload = function () {
      context.drawImage(imageObj, 0, 0);
    };
    // Calls the imageObj.onload function asynchronously, once loaded to memory
    imageObj.src = "http://www.w3.org/html/logo/downloads/HTML5_Logo_512.png";
  };
</script>

Path mode = fill a buffer then execute all buffered orders at once to enable optimization and parallelism
Call drawing methods that work in path mode, for example call ctx.rect(...) instead of ctx.strokeRect(...) or ctx.fillRect(...)
Call ctx.stroke() or ctx.fill() to draw the buffer's contents,
Beware that the buffer is never emptied, two consecutive calls to ctx.stroke() will draw the buffer contents twice! Instead, use ctx.beginPath() to empty it if needed.
Use ctx.moveTo(x,y) and ctx.lineTo(x,y) to draw lines
ctx.closePath() to connect start and end points.

Colors: set the current color using the strokeStyle and fillStyle properties of the canvas context object
Ex:
ctx.strokeStyle = 'red';
ctx.fillStyle = "#00ff00";
ctx.strokeStyle = "rgb(0, 0, 255)";
ctx.fillStyle = "rgba(0, 0, 255, 0.5)";  where a is alpha channel value between 0 (transparent) and 1 (opaque)

Example: Shadows
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
  </head>
<body onload = init();>
<canvas id="myCanvas" width="400" height =800>
  Your browser does not support the canvas tag.</canvas>
</body>
</html>

var canvas, ctx;
 
function init() {
  canvas = document.getElementById('myCanvas');
  ctx = canvas.getContext('2d');
  
  setShadow();
  
  // first green filled rectangle
  ctx.fillStyle = "#22FFDD"; // rectangle color
  ctx.fillRect(20, 20, 200, 100); 
  
  // second stroked rectangle
  ctx.strokeStyle = "purple"; // rectangle color
  ctx.lineWidth=10;
  ctx.strokeRect(20, 150, 200, 100); 
}

function setShadow() {
   ctx.shadowColor = "Grey";      // color
   ctx.shadowBlur = 20;           // blur level
   ctx.shadowOffsetX = 15;        // horizontal offset
   ctx.shadowOffsetY = 15;        // vertical offset
}

<!-- Animations -->
Before HTML5:
For animation, the setInterval(function, ms) and setTimeout(function, ms) methods were the only solutions. 
Both methods take a function as the first parameter, and a number of milliseconds as the second parameter.
The only difference is that the code provided to setInterval will run every n milliseconds whereas the 
code in setTimeout will run only once after n milliseconds
After HTML5:
The above are now completed by a new method that comes with multiple advantages: the requestAnimationFrame API.

Core example:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Animation</title>
      
    <style>
        #myCanvas {
            border: 1px solid black;
        }
    </style>
    <script>
      var canvas, ctx;
      var rectangleX = 0;
      var colors = ['red', 'blue', 'green'];
      var currentColor = 0;
      var speed = 3;
      function init() {
        // 1 - Get the canvas
        canvas = document.getElementById('myCanvas');

        // 2 - Get the context
        ctx=canvas.getContext('2d');

        // 3 - we can draw
        // Old way: using only setInterval & setTimeout unreliable timing can be imprecise if animate
        // is task-heavy.  Instead, use requestAnimationFrame to achieve 60 fps.
        //setInterval(animate, 100);
        //setTimeout(animate, 100);
        requestAnimationFrame(animate);

        // use setInterval instead to update the state of objects, such as changing color/speed.
        setInterval(changeColor, 1000);
      }
      
      function animate() {
        // - 1 clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 2 - draw a red rectangle
        ctx.fillRect(rectangleX,0,80,100);
        
        // 3 - move the shape
        rectangleX = rectangleX +speed;
        if((rectangleX+80 > 200) || (rectangleX <= 0)){
          speed = -speed;
        }
        
        // Call the animate function again after 100ms
        //setTimeout(animate, 100);   // old way of doing it
        requestAnimationFrame(animate);
      }
      
      function changeColor() {
        ctx.fillStyle= colors[currentColor%3];
        currentColor += 1;
        // Comment next line if you do not want to change the speed at each bounce
        speed += Math.sign(speed)*1;
        console.log("speed = " + speed)
      }
    </script>
    </head>

  <body onload="init();">
    <canvas id="myCanvas" width="200" height="200"> Your browser does not support the canvas tag.</canvas>
  </body>
</html>

Handling events: Target a DOM element with getElementById() and register a listener to it with addEventListener().
Define a callback associated with the event listener which would handle the event.

Example: listening to key event only when canvas has focus
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
<style type="text/css">
    canvas { 
      border:1px solid black;
    }
</style>
</head>
<body onload="init();">
  This example shows how to handle key events in a canvas by adding a key listener to the canvas object. 
  <p>If you don't want a border to appear when you click on the canvas, set its style to outline: none.</p>

  <canvas id="myCanvas" width="350" tabindex="1" height="200">
  </canvas>
  
  <script>
    var canvas;
    
    function init() {
      canvas=document.getElementById('myCanvas');
      // This will work only if the canvas has the focus.
      // To register keypress from anywhere on page, use window.addEventListener()
      canvas.addEventListener('keydown', handleKeydown, false);
      // use 'false' explicitly for backwards-compatibility of older browsers to propagate the event 
      // to the element's ancestors using bubbling phase.
      // https://stackoverflow.com/questions/17564323/what-does-the-third-parameter-false-indicate-in-document-addeventlistenerdev
      
      // We can start with focus initially on the canvas
      // canvas.focus();
    }
  
    function handleKeydown(e){
       alert('keycode: '+e.keyCode);
       return false;
    };
  </script>
</body>
</html>

The default coordinates of the mouse are its "window coordinates".  To get mouse position relative to canvas use
getBoundingClientRect() to adjust origin.
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
    <style>
      body {
        margin: 20px;
        padding: 0px;
      }
      canvas {
        border:1px solid black
      }
    </style>
  </head>
  <body>
    This is a canvas:<p></p>
    <canvas id="myCanvas" width="578" height="200"></canvas>
    <script>
      var canvas, ctx, mousePos, mouseButton;
      
      window.onload = function init() {
          canvas = document.getElementById('myCanvas');
          ctx = canvas.getContext('2d');
      
          canvas.addEventListener('mousemove', function (evt) {
              mousePos = getMousePos(canvas, evt);
              var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
              writeMessage(canvas, message);
          }, false);
      
            canvas.addEventListener('mousedown', function (evt) {
              mouseButton = evt.button;
              var message = "Mouse button " + evt.button + " down at position: " + mousePos.x + ',' + mousePos.y;
              writeMessage(canvas, message);
          }, false);
      
          canvas.addEventListener('mouseup', function (evt) {
              var message = "Mouse up at position: " + mousePos.x + ',' + mousePos.y;
              writeMessage(canvas, message);
          }, false);
      };
      
      
      
      function writeMessage(canvas, message) {
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = '18pt Calibri';
          ctx.fillStyle = 'black';
          ctx.fillText(message, 10, 25);
          ctx.restore();
      }
      
      function getMousePos(canvas, evt) {
          // necessary to take into account CSS boudaries
          var rect = canvas.getBoundingClientRect();
          return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
          };
      }
    </script>
  </body>
</html

Responsive Canvas: handling canvas resizing
Resizing a canvas can be tricky if we don't know a few rules that might not be easily guessed:
Changing the width or height property of a canvas in JavaScript erases its content and resets its context,
Using percentages (%) in the CSS width and height properties of a canvas does not change its number of pixels/resolution. Instead, it scales the existing pixels without erasing the content, giving a blurry effect when a canvas becomes larger, for example.
GOOD PRACTICE: never use CSS percentages on a canvas width or height!
The trick is to embed the canvas in a div and use CSS percentages on the div, then resize the canvas to match
the div size(contents will be erased automatically) and redraw.
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
        <style>
            #parentDiv {
                width:100%;
                height:50%;
                margin-right: 10px;
                border: 1px solid red;
            }

            canvas {
                border: 2px solid black;
            }
        </style>
        <script>
            var canvas, divcanvas, context;

            function init() {
                canvas = document.querySelector("#mycanvas");
                ctx = canvas.getContext('2d');
                divcanvas = document.querySelector("#parentDiv");

                // Let's adjust the canvas size to the parent size at start (the div)
                //resizeCanvasAccordingToParentSize();

                drawDiagonals();

                // Add an event listener for the window resize event
                window.addEventListener('resize', resizeCanvasAccordingToParentSize, false);
            }

            function resizeCanvasAccordingToParentSize() {
                // adjust canvas size
                canvas.width = divcanvas.clientWidth;
                canvas.height = divcanvas.clientHeight;
                drawDiagonals();
            }

            function drawDiagonals() {
                // draw two diagonals
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.moveTo(0, canvas.height, canvas.width, 0);
                ctx.lineTo(canvas.width, 0);
                ctx.stroke();
            }
        </script>
    </head>
    <body onload="init();">
        Try resizing the window... You can also change the percentages in the CSS
        <p><p><p>
        <div id="parentDiv">
            <canvas id="mycanvas" width="100" height="100"></canvas>
        </div> 
    </body>
</html>

Example: Collision checking
// Inits
window.onload = function init() {
  var game = new GF();
  game.start();
};


// GAME FRAMEWORK STARTS HERE
var GF = function(){
    // Vars relative to the canvas
    var canvas, ctx, w, h; 

    // vars for counting frames/s, used by the measureFPS function
    var frameCount = 0;
    var lastTime;
    var fpsContainer;
    var fps; 
  
    // vars for handling inputs
    var inputStates = {};
  
    // The monster !
    var monster = {
      x:80,
      y:80,
      width: 100,
      height : 100,
      speed:1,
       boundingCircleRadius: 70    
    };
  
    var player = {
      x:0,
      y:0,
      boundingCircleRadius: 20    
    };
  
    var measureFPS = function(newTime){
      
         // test for the very first invocation
         if(lastTime === undefined) {
           lastTime = newTime; 
           return;
         }
      
        //calculate the difference between last & current frame
        var diffTime = newTime - lastTime; 

        if (diffTime >= 1000) {
            fps = frameCount;    
            frameCount = 0;
            lastTime = newTime;
        }

        //and display it in an element we appended to the 
        // document in the start() function
       fpsContainer.innerHTML = 'FPS: ' + fps; 
       frameCount++;
    };
  
     // clears the canvas content
     function clearCanvas() {
       ctx.clearRect(0, 0, w, h);
     }
  
     // Functions for drawing the monster and maybe other objects
     function drawMyMonster() {
       // draw a big monster !
       // head
   
       // save the context
       ctx.save();
  
       // translate the coordinate system, draw relative to it
       ctx.translate(monster.x-monster.width/2, monster.y-monster.height/2);
  
       // (0, 0) is the top left corner of the monster.
       ctx.strokeRect(0, 0, monster.width, monster.height);
  
       // eyes
       ctx.fillRect(20, 20, 10, 10);
       ctx.fillRect(65, 20, 10, 10);
  
       // nose
       ctx.strokeRect(45, 40, 10, 40);
  
       // mouth
       ctx.strokeRect(35, 84, 30, 10);
  
       // teeth
       ctx.fillRect(38, 84, 10, 10);
       ctx.fillRect(52, 84, 10, 10);
       
       // Draw bounding circle
       ctx.beginPath();
       ctx.arc(50, 50, monster.boundingCircleRadius, 0, 2*Math.PI);
       ctx.stroke();
  
      // restore the context
      ctx.restore(); 
    }
  
    var mainLoop = function(time){
        //main function, called each frame 
        measureFPS(time);
      
        // Clear the canvas
        clearCanvas();
        
        // draw the monster
        drawMyMonster();
      
        // Check inputs and move the monster
        updateMonsterPosition();
      
        updatePlayer();
      
        checkCollisions();
 
        // call the animation loop every 1/60th of second
        requestAnimationFrame(mainLoop);
    };
  

  function updatePlayer() {
    // The player is just a circle, drawn at the mouse position
    // Just to test circle/circle collision.
    
    if(inputStates.mousePos) {
       player.x = inputStates.mousePos.x;
       player.y = inputStates.mousePos.y;
       ctx.beginPath();
       ctx.arc(player.x, player.y, player.boundingCircleRadius, 0, 2*Math.PI);
       ctx.stroke();
     }
  }
  
  function checkCollisions() {
    if(circleCollide(player.x, player.y, player.boundingCircleRadius, monster.x, monster.y, monster.boundingCircleRadius)) {
      ctx.fillText("Collision", 150, 20);
      ctx.strokeStyle = ctx.fillStyle = 'red';
    } else {
      ctx.fillText("No collision", 150, 20);
      ctx.strokeStyle = ctx.fillStyle = 'black';
    }
  }
  

function circleCollideNonOptimised(x1, y1, r1, x2, y2, r2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  var distance = Math.sqrt(dx * dx + dy * dy);

  return (distance < r1 + r2);  
}

function circleCollide(x1, y1, r1, x2, y2, r2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return ((dx * dx + dy * dy) < (r1 + r2)*(r1+r2));  
}
   
    function updateMonsterPosition() {
      monster.speedX = monster.speedY = 0;
        // check inputStates
        if (inputStates.left) {
            ctx.fillText("left", 150, 20);
            monster.speedX = -monster.speed;
        }
        if (inputStates.up) {
            ctx.fillText("up", 150, 40);
           monster.speedY = -monster.speed;
        }
       if (inputStates.right) {
            ctx.fillText("right", 150, 60);
            monster.speedX = monster.speed;
        }
        if (inputStates.down) {
            ctx.fillText("down", 150, 80);
            monster.speedY = monster.speed;
        } 
        if (inputStates.space) {
            ctx.fillText("space bar", 140, 100);
        }
        if (inputStates.mousePos) { 
            ctx.fillText("x = " + inputStates.mousePos.x + " y = " + inputStates.mousePos.y, 5, 200);
        }
       if (inputStates.mousedown) { 
            ctx.fillText("mousedown b" + inputStates.mouseButton, 5, 180);
            monster.speed = 5;
        } else {
          // mouse up
          monster.speed = 1;
        }
      
        monster.x += monster.speedX;
        monster.y += monster.speedY;
      
    }
  
  
    function getMousePos(evt) {
        // necessary to take into account CSS boudaries
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }
      
    var start = function(){
        // adds a div for displaying the fps value
        fpsContainer = document.createElement('div');
        document.body.appendChild(fpsContainer);
      
        // Canvas, context etc.
        canvas = document.querySelector("#myCanvas");
  
        // often useful
        w = canvas.width; 
        h = canvas.height;  
  
        // important, we will draw with this object
        ctx = canvas.getContext('2d');
        // default police for text
        ctx.font="20px Arial";
      
       //add the listener to the main, window object, and update the states
      window.addEventListener('keydown', function(event){
          if (event.keyCode === 37) {
             inputStates.left = true;
          } else if (event.keyCode === 38) {
             inputStates.up = true;
          } else if (event.keyCode === 39) {
             inputStates.right = true;
          } else if (event.keyCode === 40) {
             inputStates.down = true;
          }  else if (event.keyCode === 32) {
             inputStates.space = true;
          }
      }, false);

      //if the key will be released, change the states object 
      window.addEventListener('keyup', function(event){
          if (event.keyCode === 37) {
             inputStates.left = false;
          } else if (event.keyCode === 38) {
             inputStates.up = false;
          } else if (event.keyCode === 39) {
             inputStates.right = false;
          } else if (event.keyCode === 40) {
             inputStates.down = false;
          } else if (event.keyCode === 32) {
             inputStates.space = false;
          }
      }, false);
      
      // Mouse event listeners
      canvas.addEventListener('mousemove', function (evt) {
          inputStates.mousePos = getMousePos(evt);
      }, false);

      canvas.addEventListener('mousedown', function (evt) {
            inputStates.mousedown = true;
            inputStates.mouseButton = evt.button;
      }, false);

      canvas.addEventListener('mouseup', function (evt) {
          inputStates.mousedown = false;
      }, false);      


        // start the animation
        requestAnimationFrame(mainLoop);
    };

    //our GameFramework returns a public API visible from outside its scope
    return {
        start: start
    };
};

Example: Sprite-based animation
var spritesWoman = {
	// autant de sprites que de directions,
	// Chaque sprite dans ce tableau contient n sous images
	sprites : []
};




DIR_S= 0;
DIR_SW = 1;
DIR_W= 2;
DIR_NW = 3;
DIR_N = 4;
DIR_NE  = 5;
DIR_E = 6;
DIR_SE = 7;

var dir = DIR_S;

var moving = false;
var x = 0;
var y = 0;

var scale = 1;

function mainLoop(timestamp) {

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (moving) {
		switch(dir) {
		case DIR_E:
		    x += 6;
		    break;
		case DIR_W:
		    x -= 6;
		    break;
		case DIR_N:
		    y -= 6;
		    break;
		case DIR_S:
		    y += 6;
		}

		scale = 1 + 2 * (y / canvas.height);
    }

    if(!moving) {
        spritesWoman[dir].render(x, y, scale);
	} else {
		spritesWoman[dir].renderMoving(x, y, scale);
	}

	// recall mainLoop every 1/60th of second
    requestAnimationFrame(mainLoop);
}


window.onload = function() {	  
    canvas = document.getElementById("canvas");
    ctx = document.getElementById("canvas").getContext("2d");
  
    // load the spritesheet
    spritesheet = new Image();
    spritesheet.src="http://i.imgur.com/3VesWqx.png";
    spritesheet.onload = function() {
      
    // info about spritesheet
	var SPRITE_WIDTH = 48;
	var SPRITE_HEIGHT = 92;
	var NB_DIRECTIONS = 8;
	var NB_FRAMES_PER_POSTURE = 13;

    initSprites(spritesheet, SPRITE_WIDTH, SPRITE_HEIGHT, 
    			NB_DIRECTIONS, NB_FRAMES_PER_POSTURE);
      
      requestAnimationFrame(mainLoop);
    };
    
};

document.onkeydown = function(e) {
    e = e || window.event;

    switch (e.keyCode) {
    case 38:	
	dir = DIR_N;
	moving = true;
	break;
    case 37:
	dir = DIR_W;
	moving = true;
	break;	
    case 39:	
	dir = DIR_E;
	moving = true;
	break;
    case 40:
	dir = DIR_S;
	moving = true;
	break;
    }

};

document.onkeyup = function(e) {
    e = e || window.event;

	moving = false;
};

function SpriteImage(img, x, y, width, height) {
	this.img = img;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
  
    // xPos et yPos = position o√π dessiner le sprite,
    // scale = s'il faut rescaler.
    this.render = function(xPos, yPos, scale) {
          ctx.drawImage(this.img, 
		  this.x, this.y, 
		  this.width, this.height, 
		  xPos, yPos, 
		  this.width*scale, this.height*scale);
    };
}

function Sprite(spritesheet, x, y, width, height, nbImages, nbFramesOfAnimationBetweenRedraws) {
	this.spriteImages = [];
    this.currentFrame = 0;
    this.nbFrames = nbImages;
    this.nbTicksBetweenRedraws = nbFramesOfAnimationBetweenRedraws;
    this.nbCurrentTicks=0;

    // on parcour la ligne de l'image o√π se trouve les imagettes
    // d'animation
	for(var i = 0; i < nbImages; i++) {
		// we extract the subimage
		this.spriteImages[i] = new SpriteImage(spritesheet, x+i*width, y, width, height);
	}

	this.renderMoving = function(x, y, scale) {
		// renders animated sprite, changed every nbTicksBetweenRedraws
		// the frame number
		
		// draw the sprite with the current image
		this.spriteImages[this.currentFrame].render(x, y, scale);

		// increment the number of ticks of animation 
		this.nbCurrentTicks++;

		if(this.nbCurrentTicks > this.nbTicksBetweenRedraws) {
			// enough time elapsed, let's go to the next image
			this.currentFrame++;
			if(this.currentFrame == this.nbFrames) {
				this.currentFrame=0;
			}
			this.nbCurrentTicks = 0;
		}
	};
	this.render = function(x, y, scale) {
		// draws always frame 0, static position
		this.spriteImages[0].render(x, y, scale);
	};
}
function initSprites(spritesheet, spriteWidth, spriteHeight, nbLinesOfSprites, 
						  nbSpritesPerLine) { 	
    // on parcour l'image et pour chaque ligne (correspondant √† une direction)
    // on extrait un sprite
   	for(var i= 0; i < nbLinesOfSprites; i++) {
   		var yLineForCurrentDir = i*spriteHeight;

   		var sprite = new Sprite(spritesheet, 0, yLineForCurrentDir, 
   								spriteWidth, spriteHeight, 
   								nbSpritesPerLine,
   								3); // draw every 1s
   		spritesWoman[i] = sprite;
   	}
}


<!-- Using GUI input elements(widgets) to drive graphics in animations & chart displays
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
  </head>
<body onload="init()">
  <canvas id="canvas" width="400" height="400" style="border:solid 2px black"></canvas>  
  <ul id="sliders"></ul>
</body> 
</html>

var canvas;
var context;

// Size of the histogram
var width = 150, height=150;
// The origin, bottom left corner, relative to the origin in the canvas
var x = 40, y = 190; 

// Data to be visualized
var values = [1, 10, 2, 7, 9, 2, 34, 100, 12, 14, 19];

function init() {
    canvas = document.getElementById('canvas'); 
    context = canvas.getContext('2d'); 
  
    var list =  document.getElementById('sliders'); 
  
    // Create the sliders for changing the values.
    var max = getMax(values);
  
    for (i=0; i < values.length; i++) {
      var input = document.createElement('input');
      var li = document.createElement('li');
      var label = document.createElement('label');
      label.setAttribute('for', 'id'+i);
      label.textContent = 'value' + i + ' ';
      
      li.appendChild(label); 
      
      input.setAttribute('type', 'range');
      input.setAttribute('id', 'id' + i);
      // Set their value and max attributes correctly
      input.setAttribute('max', max);
      input.value = values[i]; 
      // Add an onchange event listener and pass the
      // index of the slider to the callback
      input.setAttribute('oninput', 'changeValue(' + i + ')');
      li.appendChild(input);
      
      list.appendChild(li);
    }
 
    makeHistogram(x, y, 
                  width, height, 
                  values);  
  // center of pie x and y, radius, values
  makePieChart(300, 100, 90, values); 
  
  // Draw broken lines chart
  makeBrokenLines(40, 370, width, height, values);
}

// callback for sliders' onchange events. 
function changeValue(index) {
    var value = document.getElementById("id"+index).value; 
  
    // put the slider value in the values array
    values[parseInt(index)] = parseInt(value); 
  
    // clear the canvas
    context.clearRect(0,0, canvas.width, canvas.height); 
    
    // redraw the charts
    makeHistogram(x, y, width, height, values);  
    makePieChart(300, 100, 90, values); 
    makeBrokenLines(40, 370, width, height, values);
}           
// returns the max from the elements of the values array.
function getMax(values) {
    var maxValue = 0;
  
    for (i=0; i<values.length; i++) {
        if (maxValue < values[i])
            maxValue = values[i];
    }
  return maxValue;
}

function drawAxis(width, height,  values, maxValue) {
	// remember: we have the origin of the coordinate system at bottom left
	// Y values above will be negative
	  
    context.strokeStyle = "black"; //We draw in black the outline.
    context.fillStyle = "black"; //We fill in black.
  
    //We define the vertical step unit. Is it 10 ? 20 ? 100 ? 1000 ? Depending on the
    // max unit value, we decide how the steps will be for the ticks
    var unit = 1; 
    while (maxValue / (unit*10) > 1) {
        unit *= 10; 
    }
  
   //We define the highest vertical step.
    var yMaxOnAxis = parseInt(maxValue) / unit;   
  
    // Everything is in a path, all drawing orders will be drawn by a final call
    // to context.stroke() at the end of the function.
    context.beginPath(); //Begin a new path.
  
    // Draw the axis' lines
    context.moveTo(0, 0); //We place the cursor to origin.
    context.lineTo(0, -height); //We draw the vertical line.
    context.moveTo(0, 0); //We place the cursor to origin.
    context.lineTo(width, 0); //We draw the horizontal line.


    // ticks/labels on the vertical line
    context.textAlign = "left";

    for (i=0; i <= yMaxOnAxis; i++) {
        // move to the next graduation. the y value is negative due to
        // the change of the origin by a call to translate(x,y) in the drawHistogram
        // function.
        context.moveTo(0, -height / yMaxOnAxis * i );
      
        // draw an horizontal line, 5 pixels long, on the left of the axis
        context.lineTo(-5, -height / yMaxOnAxis * i ); 
      
        // write the tick value, 25 pixels on the left of the axis
        context.fillText(i*unit, -25, -height / yMaxOnAxis * i ); 
    }

    // Ticks/labels on the horizontal line
    var counter = 0; 
    // text centered below the tick
    context.textAlign = "center"; 

  
    // graduation on the horizontal line.
    var rectanglesWidth = width / values.length;
    
    for (i=0; i <= values.length; i++) {
    	  // Move to the next horizontal position of the tick
        context.moveTo(i*rectanglesWidth , 0); 
        // draw a vertical line 5 pixels long: the tick
        context.lineTo(i*rectanglesWidth , 5); 
        // write tick label  15 pixels below the tick
        context.fillText(i, i*rectanglesWidth , 15); 
        counter++;
    }
    // Draw everything in the path
    context.stroke(); 
    
}

// MakeHistogram building a bar plot. x, y is the bottom left position of the
// histogram. Easier to reason with this coordonate system
function makeHistogram(x, y, width, height, values) {
    context.save();
    // Change the origin at bottom left. If we draw "above", Y values will be negative.
    // y=0 is the horizontal line at bottom
    context.translate(x, y);
    
    // Compute the max of the values array
    var maxValue = getMax(values);
  
    // step in pixels between two horizontal values for bar plot.
    var rectWidth = width / parseFloat(values.length); 

    // step in pixels between two vertical values for bar plot.
    var vStep = -height / parseFloat(maxValue); 
   
    //Set fill color to red and stroke color to black.
    context.fillStyle = "red"; 
    context.strokeStyle = "black";
 
    // Draw the histogram rectangles
    for(i=0; i < values.length; i++) {       
        //We draw a filled red rectangle to represent the current value.
        context.fillRect(i * rectWidth, 0, 
                         rectWidth, vStep * values[i]); 
      
       //We draw the outline of rectangle.
        context.strokeRect(i * rectWidth, 0, 
                           rectWidth, vStep * values[i]); 
    }
  
  // draw the axis
  drawAxis(width, height, values, maxValue); 
  
  context.restore();
}

//makePieChart draw a circle graph with values table.
function makePieChart(cx, cy, radius, values) {
  context.save();
  
    // Compute the sum of all values
    var sum=0;
    for(var n=0; n < values.length; n++) {
      sum += values[n];
    }
  
    //Initialization of red green blue colors.
    var red = 0;
    var green = 0;
    var blue = 0;

  //starting and ending angles of each pie section
    var startingAngle = 0; 
    var endAngle = 0; 
   //The percentage the current value represents, compare to the total,
  // we are in a closed circle, the sum is 100%
    var percentage;

  //We draw in grey the outline of the section.
  context.strokeStyle = "grey"; 
  
  // Draw the pie chart, clockwise, √† la HTML5
  //for (var i=values.length-1; i> 0; i--) { // for ccw display 
  for(var i = 0; i < values.length; i++) {
        context.beginPath(); //Begin a new path.

        // We change the colors depending on the i-value. Just a trick based
        // on the modulo. Will produce different colors for the pie sections
        switch (i%3) {
            case 0: //If i modulo 3 equals 0:
                red += 80; //We add red.
                break;
            case 1: //If i modulo 3 equals 1:
                green += 80; //We add green.
                break;
            case 2: //If i modulo 3 equals 2:
                blue += 80; //We add blue.
                break;
            default: //If there is an error.
                alert("we have encountered an error");
                return ; //and we stop makePieChart.
        }
        context.fillStyle = "rgb(" + red + "," + green + "," + blue +")"; 
    
        // percentage of the circle for current section, will give the angles
        percentage = values[i] / parseFloat(sum); 
        endAngle = startingAngle + Math.PI*2*percentage; 

        // draw an arc between starting angle and end angle.
        context.arc(cx, cy, radius, startingAngle, endAngle); 
       // draw a line between end angle and center of circle.
        context.lineTo(cx, cy); 
    
        //The next starting angle is the current end angle.
        startingAngle = endAngle; 

        context.fill();      // draw pie section
        context.stroke();    // draw the outline.
        context.closePath(); // Close the path.
      
        context.restore();
    }
}
  
// draw a broken line chart
function makeBrokenLines(x, y, width, height, values) {
    context.save();
    // Move origin of the coordinate system at x, y, bottom left corner
    context.translate(x, y);
  
    var maxValue = getMax(values);
  
    // distance between two horizontal values, in pixels
    var hStep = width / parseFloat(values.length); 
  
    // step between two vertical values, in pixels
    var vStep = -height / parseFloat(maxValue); 

    // set fill color to black, for drawing the circle plots
    context.fillStyle = "black"; 
    // thickness of the lines
    context. lineWidth = 1; 
  
    // set the cursor to origin.
    context.moveTo(0 , 0); 

    // All lines are drawn into a path
    context.beginPath();
    for(i=0; i<values.length; i++) { 
        context.lineTo(i * hStep, vStep * values[i]);        
    }
    context.stroke(); // draw the path with all the lines

    // Draw the filled black circles at each coordinate of the value
    for(i=0; i<values.length; i++) { 
        context.beginPath(); 
        context.arc(i * hStep, vStep * values[i], 3, 0, 2*Math.PI); 
        context.fill(); //We fill all circles.
    }
  // draw the X and Y axis
  drawAxis(width, height, values, maxValue); 
  
  context.restore();
}


<!----- Forms ------>
Explore: HTML5 client side validation, input tags and attributes.
Form example using lists: https://jsbin.com/sivula/edit?html,css,js,output
Form example using fieldset/legend structure: http://dev.dhc3.intrasoft-intl.com/html5/philipbkemp/forum.html

Basic Example:
(match the label's 'for' attr with the input's 'id' attr.  Good practice for accessibility and
clicking on label selects the associated input element in the form)
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Form example</title>
</head>
<body>
<form id="myForm">
  <fieldset>
    <legend>Personal informations</legend>
    
    <!-- inputs come with some basic validation depending on the specfied type,
         and CSS can respond by using input:valid or input:invalid (see CSS below). -->
    <label for="firstName">First name:</label>
    <input type="text" id="firstName" required name="firstName">
    
    <br>
    
    <label for="lastName">Last name:</label>
    <input type="text" id="lastName" required name="lastName">
    
    <br>
     <label for="email">Email:</label>
    <input type="email" id="email" required name="email">
    
     <br>
     <label for="age">Age:</label>
    <input type="number" min=0 max=120  step=5 id="age" required name="age">
 
     <br>
     <label for="date">Birth date:</label>
    <input type="date"  id="date" required name="date">
  </fieldset>
  
  <button>Submit form</button>
  </form>
</body>
</html>

CSS
fieldset {
  padding:10px;
  border-radius:10px;    /* for rounded corners */
}

label {
  display:inline-block;  /* block: each label contained in it's own "paragraph".  
                            inline: lets us put the labels inline right next to the associated input boxes 
                         */
  margin-bottom:10px;    /* specify amount of margin between label blocks */
}

*/ This setup lets us align the input boxes regardless of the character length of our labels */
input {
  float:right;
  margin-right:70px;
  width:150px;
}

*/ change the input box background color according to the data validation */
input:invalid {
  background-color:pink;
}

input:valid {
  background-color:lightgreen;
}

<!-- 13 new input types (typically used within forms) -->
HTML4: button, checkbox, file, hidden, image, password, radio, reset, submit, text.
HTML5: color, email, number, range, search, tel, url, and 5 variants for choosing dates:
       date, datetime, datetime-local, month, time, week.
Browsers providing native implementation will give boost to performance and reduce size of embedded JS.

Example: change background color using color picker
<!DOCTYPE html>
<html lang="en"><head></head>
<body>
  Select a color : <input type="color" id="colorChooser"/>
  <script>
     var colorInputField = document.querySelector("#colorChooser");
     colorInputField.addEventListener('input', function(evt) {
          document.body.style.backgroundColor = this.value;
      }, false);
</script>
</body>
</html>

Example: limit user's available color options.  Use datalist with id matching the list attr of input.
Datalist good for linking a list of choices to an input element.
<input type="color" value="#333333" list="colors">
<datalist id="colors">
     <option>#0000FF</option>
     <option>#00FF00</option>
     <option>#FF0000</option>
</datalist>

Example: color picker polyfill - spectrum.js  The downsides to this color picker: it's appearance is often
dependent on browser and OS, the location where the dialog window will appear can't be controlled.  W3C suggests
using Web Components instead.
Spectrum example:
https://jsbin.com/wibekaditi/edit?html,output
Add these lines between head tags:
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.7.0/spectrum.min.js"></script>
<link rel="stylesheet" type="text/css"
      href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.6.1/spectrum.min.css">
or
Download the spectrum.js library and reference directly:
<!doctype html>
<html lang="en">
<head>
<title>Spectrum polyfill example, for input type=color</title>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../spectrum.css">
<script type="text/javascript" src="../docs/jquery-1.9.1.js"></script>
<script type="text/javascript" src="../spectrum.js"></script>
</head>
<body>
     <input type="color" onchange="alert(this.value);"></p>
</body>
</html>

<!-- Date input -->
<input type="date"
    id="birthdayParty"
    value="2015-06-20"
    min="2015-06-20"
    max="2015-06-30"
    step="7">

using <datalist> to specify which dates possible options.
<input type="date"
    id="birthdayParty"
    list="birthdayPartyPossibleDates"
    value="2015-06-20">
<datalist id="birthdayPartyPossibleDates">
     <option label="Best for me">2015-06-20</option>
     <option label="Ok for me too ">2015-06-27</option>
     <option label="This one is a sunday, hmmm">2015-06-28</option>
</datalist>

Listening to date input event
<input type="date" id="date" />
...
<script>
  var field = document.querySelector("#date");
  field.oninput = function(evt) {
    var date = this.value;
    pickedDate.innerHTML = "<b>"+date+"</b>";
  }
</script>


Other Input Types:
<input type="email">, <input type="tel">, <input type="URL"> and <input type="search">

Input type: "tel" (for smartphones and tablets, a keyboard layout automatically pops up)
<label for="tel">Enter a telephone number:</label>
<input type="tel" id="tel"
        placeholder="(555) 555-5555"
        pattern="^(?\d{3})?[-\s]\d{3}[-\s]\d{4}.*?\)"/>

Input type: "url" (for smartphones and tablets, a keyboard layout automatically pops up)
<input type="url1" id="url"/>
 <p>
<label for="url2">Enter a URL (custom validation, must start with http, https or ftp):</label>
    <input id="url2" type="url" placeholder="http://www.domain.com"
           pattern="(http|https|ftp)\:\/\/[a-zA-Z0-9\-\.\/]*"/><p>

Example simple validation using CSS:
<form>
  <label for="url_input">Enter a URL:</label>
  <input type="url" id="url_input" />
  <br />
  <br />
  <label for="email_input">Enter an email address:</label>
  <input type="email" id="email_input" required/>
</form>

input:invalid {
  background-color: #ffdddd;
}

form:invalid {
  border: 5px solid #ffdddd;
}

input:valid {
  background-color: #ddffdd;
}

form:valid {
  border: 5px solid #ddffdd;
}
  
input:required {  /* or refer using #email_input:required */
  border-color: #800000;
  border-width: 3px;
}

input:required:invalid {
  border-color: #C00000;
}

Number input type:
<input type="number">
Good for entering integers and floats but not zipcodes which should use text type with a pattern matching possible hyphen

Range input type:
<script>
      window.onload = function() {
        printValue('slider1','rangeValue1');
      }
      function printValue(sliderId, outputId) {
      var x = document.getElementById(outputId);
      var y = document.getElementById(sliderId);
      x.value = y.value;
      }
</script>
  </head>
  <body>
    <form >
      <label for="slider1">Select a value:</label>
      <input id="slider1" type="range"
        min="100" max="500" step="10" value="150"
        oninput="printValue('slider1','rangeValue1')"/>
      <output id="rangeValue1"></output>
    </form>
    <br/>
      Play with attributes: value, min, max, step...
  </body>

HTML5 Attributes
form
readonly
autocomplete
autofocus
list
pattern
required*
placeholder
multiple
list
min
max
step
formaction
formenctype
formmethod
formtarget
formnovalidate

<!-- Form -->
Useful for putting input fields outside the form itself.  Good in conjunction with <fieldset> for page/form layout.
  <body>
    <label for="yourName">Enter your name:</label>
    <input type="text" id="yourName" name="yourName" form="form1"/>   <!-- This textbox will be outside the fieldset box -->
    <p>
    <form id="form1" action="sumit.php" method="post">
      <fieldset>
        <legend>Choose option</legend>
        <label for="free">Free registering</label>
        <input type="checkbox" id="free"/>
        <label for="premium">Premium</label>
        <input type="checkbox" id="premium"/>
        <button type="submit">Send form</button>
      </fieldset>
    </form>
  </body>

<!-- Autofocus -->
Default focus is given to first input field of page.  To specify another input field's focus on page load,
use autofocus attr.  No more than one input element should have this attr.

<!-- List with datalist -->
Enables autocomplete with dropdown of matching options.
<form>
    ...
    <input list="browsers" id="mybrowser" />
    <datalist id="browsers">
       <option value="Internet Explorer">
       <option value="Firefox">
       <option value="Chrome">
       <option value="Opera">
       <option value="Safari">
    </datalist>
...
</form>

<!-- Pattern -->
The pattern attribute enables the validation of the user's input on the fly (also at submission time), 
based on regular expressions. It applies to the text, search, url, tel, email, and password input types. 
Ready-to-go patterns at http://html5pattern.com/
Regex tester: https://regex101.com/#javascript

<!-- Multiple -->
The multiple attribute is used with email and file input types
Used for entering multiple comma-separated emails or selecting multiple files.

<!-- Form elements -->
<datalist>
<output>
<meter>
<progress>

<!-- Output -->
As input field values are considered as strings by JavaScript, using x.value = a.value + b.value 
would result in a string concatenation instead of an addition. That's why we use the valueAsNumber property.
HTML5 has introduced new input field properties: valueAsNumber and valueAsDate. 
The last example is similar to the previous one except that we use an addition instead of a multiplication.

As input field values are considered as strings by JavaScript, using x.value = a.value + b.value would 
result in a string concatenation instead of an addition. That's why we use the valueAsNumber property.
<body>
  Example 1 :<p>
<form oninput="o.value=a.value*b.value">
  <input type="number" name="a" value="2"> x
  <input type="number" name="b" value="3"> =
  <output for="a b"    name="o">6</output>
</form>
  
  Example 2 :<p>
<form oninput="x.value=a.valueAsNumber+b.valueAsNumber">
  <input type="range" name="a" value="50" /> 100+
  <input type="number" name="b" value="50" /> = 
  <output for="a b" name="x"></output>
</form>

<!-- Meter -->
Display colored gauge bar to correspond to range widget
<body>
<pre>&lt;meter value=75 min=0 low=20 high=80 max=100 optimum=19 &gt;&lt;/meter&gt;</pre>

<p>Grades: <meter id="meter2" value="75"  min=0 low=20  high=80 max=100 optimum=19>75%</meter> 
  
<input min="0" max="100"   value="75" id="meter2range" oninput="effect('meter2', 'meter2range')" type="range"> 
  <output id="meter2val" for="meter2range"></output></p>
 <script>
 function effect(meter, meterrange) {
	var currVal = document.getElementById(meterrange).value;
	document.getElementById(meter).value =  currVal;
	document.getElementById(meter+ "val").innerHTML = currVal;
 }
 </script>
</body>

<!-- Progress -->
Download progress:  <progress id=pr value=500  max=1000></progress> 
  <script>
    var i=500;
window.setInterval(function () {
  i = (i+1) %1000;
  document.getElementById('pr').value = i;
},1);
  </script>
</body>

More on realtime data validation using CSS3
Use 'title' attr to customize dialogue box msg associated with invalid data input.

      input:invalid { background-color: lightPink;}
      input:valid { background-color:lightGreen; }
      input:required {border: 2px solid red;}
      input:optional {border: 2px solid green;}

Example using icon inside input field to indicate validity of data.
<!DOCTYPE html>
<html>
  <head>
    <title>CSS3 pseudo-classes for form validation visual feedback</title>
<style>
.myForm input:required:valid { background:url('http://i.imgur.com/BJolppS.png') no-repeat right top;
}
.myForm input:required {
  background:url('http://i.imgur.com/7pIN7wz.png') no-repeat right top;
}
</style>
  </head>
<body>

<form class="myForm">
  <fieldset>
    <legend>Type invalid values and see the result</legend>
  <label for="myEmail" class="formLabel">E-mail:</label> <input type="email" id="myEmail" required/><br>
    <button>Submit form</button><br />
  </fieldset>
</form>

</body>
</html>

Ensuring 2nd password matchest first, and using setCustomValidity() to customize dialog msg for invalid input.
An empty string msg indicates valid data.
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Example of using the validation API</title>
    <style>
      .myForm input:invalid { background-color: lightPink;}
      .myForm input:valid { background-color:lightGreen; }
      .myForm input:required {border: 2px solid red;}
      .myForm input:optional {border: 2px solid green;}
      .myForm label { display: inline-block; width: 140px; text-align: right; } 
    </style>
  </head>

  <body>
    <form class="myForm">
      <fieldset>
        <legend>Example use of the validation API</legend>
          <label for="password1" >Password:</label> <input type="password" id="password1" oninput="checkPasswords()" required>
          <p>
          <label for="password2">Repeat password:</label> <input type="password" id="password2" oninput="checkPasswords()" required>
          <p>
       <button>Submit</button>
      </fieldset>
    </form>
    
    <script> 
     function checkPasswords() {
       var password1 = document.getElementById('password1');
       var password2 = document.getElementById('password2');
       if (password1.value != password2.value) {
         password2.setCustomValidity('Passwords non identiques');
       } else {
         password2.setCustomValidity('');
       }
     }
    </script>
  </body>
</html>

<!-- Fine tuning validation messages using validity property of input elements -->
<!-- can also access the messages using 
console.log("Validation message = " + input.validationMessage);
-->
<body>  
  <script>
    function validate() {
      var input = document.getElementById('b');
      var validityState_object = input.validity;
      
      if(validityState_object.valueMissing) {
         input.setCustomValidity('Please set an age (required)');	
      } else if (validityState_object.rangeUnderflow) {
         input.setCustomValidity('Your value is too low');
      } else if (validityState_object.rangeOverflow) {
         input.setCustomValidity('Your value is too high');
      } else if (validityState_object.typeMismatch) {
         input.setCustomValidity('Type mismatch');
      } else if (validityState_object.tooLong) {
         input.setCustomValidity('Too long');
      } else if (validityState_object.stepMismatch) {
         input.setCustomValidity('stepMismatch');
      } else if (validityState_object.patternMismatch) {
         input.setCustomValidity('patternMismatch');
      } else {
        input.setCustomValidity('');
      }
    }
  </script>
  <form>
      <label for="b">Enter a value between 10 and 20 </label> 

      <input  type="number" name="text" id="b"
              required  min="10" max ="20" step="1" oninput='validate()'/>    
        <input type="submit"/>
  </form>
  
</body>

<!-- Custom validation: changing the default behavior, aggregating error messages, removing bubbles, etc. -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Aggregating error messages</title>
        <style>
            input:invalid { background-color: lightPink;}
            input:valid { background-color:lightGreen; }
            input:required {border: 2px solid red;}
            input:optional {border: 2px solid green;}

            .error-messages {
                display: none;
                margin: 0 10px 15px 10px;
                padding: 8px 35px 8px 30px;
                color: #B94A48;
                background-color: #F2DEDE;
                border: 2px solid #EED3D7;
                border-radius: 4px;
            }
            fieldset {
                border:1px solid;
                padding:20px;
            }
           label { display: inline-block; width: 140px; text-align: right; } 
        </style>
    </head>
    <body>
        <form>
            <fieldset>
              <legend>Submit with one or two invalid fields </legend>
                <ul class="error-messages"></ul>
                <label for="name">Name:</label>
                <input id="name" name="name" required>
                <p>
                    <label for="email">Email:</label>
                    <input id="email" name="email" type="email" required>
                <p>
                    <button>Submit</button>
            </fieldset>

        </form>

        <script>
            function replaceValidationUI(form) {
                // Suppress the default bubbles
                form.addEventListener("invalid", function (event) {
                    event.preventDefault();
                }, true);

                // Support Safari, iOS Safari, and the Android browser‚Äîeach of which do not prevent
                // form submissions by default
                form.addEventListener("submit", function (event) {
                    if (!this.checkValidity()) {
                        event.preventDefault();
                    }
                });

                // Container that holds error messages. By default it has a CSS display:none property
                var errorMessages = form.querySelector(".error-messages");

                var submitButton = form.querySelector("button:not([type=button]), input[type=submit]");

                submitButton.addEventListener("click", function (event) {
                    var invalidFields = form.querySelectorAll("input:invalid"),
                            listHtml = "",
                            errorMessagesContainer = form.querySelector(".error-messages"),
                            label;

                    // Get the labels' values of their name attributes + the validation error
                    // message of the corresponding input field using the validationMessage
                    // property of input fields
                    // We build a list of <li>...</li> that we add to the error message container
                    for (var i = 0; i < invalidFields.length; i++) {
                        label = form.querySelector("label[for=" + invalidFields[ i ].id + "]");
                        listHtml += "<li>" +
                                label.innerHTML +
                                " " +
                                invalidFields[ i ].validationMessage +
                                "</li>";
                    }

                    // Update the list with the new error messages
                    errorMessagesContainer.innerHTML = listHtml;

                    // If there are errors, give focus to the first invalid field and show
                    // the error messages container by setting its CSS property display=block
                    if (invalidFields.length > 0) {
                        invalidFields[ 0 ].focus();
                        errorMessagesContainer.style.display = "block";
                    }
                });
            }

            // Replace the validation UI for all forms
            var forms = document.querySelectorAll("form");
          
            for (var i = 0; i < forms.length; i++) {
                replaceValidationUI(forms[ i ]);
            }
        </script>
    </body>
</html>

<!------ HTML5 JavaScript APIs ------>

<!-- HTML5 cache / offline applications -->
Caching is not a new feature of HTML, but with HTML5 there is more control of what or what not to cache
at the application layer.
Specify cache file inside of which lists all files that need to be cached, including images, libraries like jquery, etc.
<html manifest="myCache.appcache">
...
</html>
Any html page with manifest will be cached by default.
Example manifest file(must have CACHE MANIFEST first line):
CACHE MANIFEST
clock.html
clock.css
clock.js

The HTTP server that serves your files must be configured so that .appcache files are served with the
MIME type text/cache-manifest. For example, with the Apache server, this line must be added in the 
HTTP.conf configuration file (or in the .htaccess files): 
AddType text/cache-manifest .appcache

PITFALL #1 : When a file is available in the cache and on the remote HTTP server, it will always be retrieved from the cache!
PITFALL #2: If one file cannot be retrieved and cached, none of the files will be updated in the cache.

Another manifest file example:
The CACHE section specifies the URLs of the resources that must be cached
The NETWORK section is the contrary of the CACHE section: it is useful for specifying resources that should NOT be cached.
The FALLBACK section specifies resources that will be displayed when the user requests a resource that is not available when offline. 

CACHE MANIFEST
CACHE:
#images      # for comment
/images/image1.png
/images/image2.png
#pages
/pages/page1.html
/pages/page2.html
#CSS
/style/style.css
#scripts
/js/script.js
FALLBACK:
/ /offline.html
NETWORK:
login.html

Tools for generating manifest files:
1. ManifestR: a manifest file generator (http://westciv.com/tools/manifestR/)
manifestR is a bookmarklet, meaning that you are able to drag it to your bookmarks bar. Then, when you visit 
a page, you will click on the manifestR button, and it will create an HTML5 appcache manifest file for that page.

2. Confess.js: multi purpose command line tools
Confess.js is a small script library that uses PhantomJS 1.2 (or later) to analyze Web pages. Currently it can perform the following tasks:

Generation of an appcache manifest for a Web app
Simple performance analysis of a Web page and its resources
List of CSS properties used on the page

3. Cache validators
Manifesto is an HTML5 Offline Application Cache verification bookmarklet.

When a resource is in the cache, it will ALWAYS be retrieved from the cache, even if you are online, and even if a more recent version is available on your Web server.
To force an update, best practice is to update the manifest file server side.  Modifying the manifest file triggers browser to check if all files under CACHE section needs updating.

Clearing cache for debugging in Chrome: dev tools - application tab, clear storage

Cache size is limited, but generally sufficient.  Browser also knows to extend size if when needed.

To check status of browser, use navigator.online
Note this only checks for local network connectivity and doesn't guarantee the remote server is up or that the DNS server is operational.

<!-- Web storage API: localStorage, sessionStorage -->

