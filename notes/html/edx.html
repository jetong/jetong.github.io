Best practices
Title pages, use alt for images, web internationalization
<meta charset="utf-i"/>
<html lang="fr">
"type" attribute in link and script tags are optional

for accessibility and portability, split page content into regions using aside, footer, header, main, nav.
<section>
   <article>
     <header>
       Heading
     </header>
     <p>
       Some content.
       Some content.
       Some content.
     </p>
     <figure>
       <img src="some_pic.png" alt="some picture" />
         <figcaption>
             Fig. 1 : some pic... 
         </figcaption>
     </figure>
   <article>
    ...
   </article>
<section>
<!---------------------------------------->
<!-- FlexBox -->
<!-- associate an element with the 'flex-container' css class, then 
     its child elements automatically become flexible items. --> 
<!DOCTYPE html>
<html>
<head>
<style>
.flex-container {
  display: flex;
  background-color: Blue;
}

.flex-container > div {
  background-color: #11f1f1;
  margin: 10px;
  padding: 20px;
  font-size: 30px;
  width:30%;
}
</style>
</head>

<body>
<div class="flex-container">
  <div>1</div>
  <div>2</div>
  <div>3</div>  
</div>
</body>
</html>

<!---------------------------------------->
<!-- details & summary tags to create simple widget to hide/show contents -->
<!-- The summary element is not supported in Edge/Internet Explorer -->
<details>
  <summary>Copyright 1999-2014.</summary>
  <p> - by Refsnes Data. All Rights Reserved.</p>
</details>

<!-- css to format details & summary -->
summary::-webkit-details-marker {
 color:#FF0000; 
 background:#FFFFFF; 
}

details[open] summary::-webkit-details-marker {
	color:#0000FF;
	background:#00FFFF;
}

<!---------------------------------------->
polyfills - fallback javascript code that emulates an HTML5 feature not yet implemented certain browsers
http://caniuse.com
http://html5please.com
modernizr on github
Search for the particular HTML5 feature to see browser support and check for fallback script in resources tab

<!---------------------------------------->
<time> tag for flexibility in outputing various date formats for readers while making it 
easier for programs to index date data and allowing search engines and other programs to 
quickly locate and parse them.

<!---------------------------------------->
<mark> for highlighting text

<!---------------------------------------->
Download attribute.
<a href="https://www.somewhere.com/picture.gif" download="pic.gif">Download Picture</a>
Enables ability to force a download rather than navigating to the file.  Downloaded filename can be specified as well.

<!---------------------------------------->
Translate attribute.
<span translate="no">Linda</span>
Prevent/limit the impact of translation tools such as Google Translate.
This person's name would otherwise be translated into "Pretty" in Spanish.
Any children of the attributed elemented will also inherit the attribute.

<!-- Video embedding -->
Old way:
<object width="425" height="344">
   <param name="movie"
          value="http://www.youtube.com/v/9sEI1AUFJKw&hl=en_GB&fs=1&">
   </param>
   <param name="allowFullScreen"   value="true"></param>
   <param name="allowscriptaccess" value="always"></param>
   <embed src="http://www.youtube.com/v/9sEI1AUFJKw&hl=en_GB&fs=1&"
          type="application/x-shockwave-flash"
          allowscriptaccess="always" allowfullscreen="true"
          width="425" height="344">
   </embed>
</object>

HTML5
<!-- <video> tag, with the @controls attribute giving it the play/pause/seeker controls. 
     autoplay or loop, and can style using css since <video> is part ot the DOM -->
<video id="vid" controls autoplay> 
	<!-- I have three versions of the video encoded with
	     different codecs.  The browser will automatically
	     choose the first one it knows it can play. --> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.webm type=video/webm> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.ogg type=video/ogg> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.mp4 type=video/mp4> 
</video> 
<button onclick="playVideo();" style="cursor: pointer;">Play</button>
<button onclick="pauseVideo();" style="cursor: pointer;">Pause</button>
<button onclick="rewindVideo();" style="cursor: pointer;">Back to beginning</button>
<script>
  vid = document.querySelector("#vid");
  function playVideo() { vid.play(); }
  function pauseVideo() { vid.pause(); }
  function rewindVideo() { vid.currentTime = 0; }
</script>
<!-- That's it!  You now have video playing in your browser! -->

CSS for fullscreen video
body {
  margin:0;
  padding:0;
  overflow:hidden;
}
 
video {
  width:100%;
  height:auto;
}

To detect end of video and do something else (like play another video), listen for 'ended' event
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Sequential Movies</title>
    <script>
      var myVideo;
      var currentVideo = 0;
      var sources = [
        "https://mainline.i3s.unice.fr/mooc/samuraiPizzacat.mp4",
        "http://www.archive.org/download/AnimatedMechanicalArtPiecesAtMit/P1120973_512kb.mp4"
        ];
      // Set the src of the video to the next URL in the playlist
      function loadNextVideo() {
        myVideo.src = sources[currentVideo % sources.length]
        myVideo.load();
        currentVideo++;
      }
      // called by addEventListener
      function loadAndplayNextVideo() {
        console.log("playing " + sources[currentVideo % sources.length])
        loadNextVideo();
        myVideo.play();
      }
      function init(){
        myVideo = document.querySelector("#myVideo");
        // Define a callback function called each time a video ended
        myVideo.addEventListener('ended', loadAndplayNextVideo, false);
        // Load the first video when the page is loaded.
        loadNextVideo();
      }
    </script>
  </head>
<body onload="init()">
    <video id="myVideo"
      controls>
    </video>
</body>
</html>

For YouTube, Dailymotion, Vimeo, etc, need to embed differently:
(right click on video and select 'copy embed code')
(licensing and royalties prevent certain videos from playing)
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZH1XOsv8Oyo" frameborder="0" allowfullscreen></iframe>

<!-- Audio -->
<audio controls="controls">
   <source src="https://mainline.i3s.unice.fr/mooc/horse.ogg" type="audio/ogg" />
   <source src="https://mainline.i3s.unice.fr/mooc/horse.mp3" type="audio/mp3" />
      Your browser does not support the audio element.
      Download the audio/video in
   <a href="https://mainline.i3s.unice.fr/mooc/horse.ogg">OGG</a>
   or <a href="https://mainline.i3s.unice.fr/mooc/horse.mp3">MP3</a>
   format.
</audio>

Example using CSS3 transformations on video: https://jsbin.com/lunosev/1/edit?html,css,js,output

Example using filters in real time: https://jsbin.com/siduxad/edit?html,output

Example handling video errors and logs: https://jsbin.com/becaref/3/edit?html,output

Example displaying buffer progress indicator: https://jsbin.com/xororol/3/edit?html,output

Adding closed captions and subtitles using <track>:
http://www.universalsubtitles.org, also known as http://www.amara.org.  Allow uploading
YouTube video and offers online editor.

<!-- Graphics using <canvas> -->
Ensure page is loaded before running js either:
<body onload="init();">
or
in script, use window.onload = function() { get canvas object, etc };
or
place <script></script> tags at the very end
or
use defer

Steps:
1.  Declare the canvas, remembering to add an id attribute, and fallback content:  
<canvas id="myCanvas" width="200" height="200">
...fallback content...
</canvas>
2.  Get a reference to the canvas in a JavaScript variable using the DOM API: 
    var canvas=document.getElementById('myCanvas');
3.  Get the context for drawing in that canvas:  
    var ctx=canvas.getContext('2d');
4.  Specify some drawing properties (optional):  
    ctx.fillStyle='#FF0000';
5.  Draw some shapes: 
    ctx.fillRect(0,0,80,100);

Example
<!DOCTYPE html>
<html lang="en">
 <head>
   <title>Drawing principales unit√©</title>
  <meta charset="utf-8"/>
 <style>
     #myCanvas {
         border: 1px solid black;
     }
 </style>
 <script>
   var canvas, ctx;
 
   function init() {
     // 1 - Get the canvas
     canvas = document.getElementById('myCanvas');
     // 2 - Get the context
     ctx=canvas.getContext('2d');

     // Optionally do transformations to the context before drawing
     ctx.translate(100, 100);
     ctx.rotate(Math.PI/4);
     ctx.scale(0.5, 0.5);

     // 3 - we can draw
     drawSomething();
   }
   function drawSomething() {
     // draw a red rectangle, line width=3 pixels
     ctx.lineWidth=3;
     ctx.strokeStyle='red';
     ctx.strokeRect(10,10,80,100);
   }
 </script>
 </head>
<body onload="init();">
    <canvas id="myCanvas" width="200" height="200">
            Your browser does not support the canvas tag.
    </canvas>
</body>
</html>

There are two methods for saving and restoring the context properties: ctx.save()and ctx.restore().
Best practice: save the context at the beginning of any function 
that changes the context, restore it at the end of the function!

To draw an image from a file source, make sure web page loaded, and make sure image is loaded in memory first:
<script>
  // wait for page to load
  window.onload = function () {
    var canvas = document.getElementById("myCanvas");
    var context = canvas.getContext("2d");
    var imageObj = new Image();
    // wait for image to load into memory before drawing
    imageObj.onload = function () {
      context.drawImage(imageObj, 0, 0);
    };
    // Calls the imageObj.onload function asynchronously, once loaded to memory
    imageObj.src = "http://www.w3.org/html/logo/downloads/HTML5_Logo_512.png";
  };
</script>

Path mode = fill a buffer then execute all buffered orders at once to enable optimization and parallelism
Call drawing methods that work in path mode, for example call ctx.rect(...) instead of ctx.strokeRect(...) or ctx.fillRect(...)
Call ctx.stroke() or ctx.fill() to draw the buffer's contents,
Beware that the buffer is never emptied, two consecutive calls to ctx.stroke() will draw the buffer contents twice! Instead, use ctx.beginPath() to empty it if needed.
Use ctx.moveTo(x,y) and ctx.lineTo(x,y) to draw lines
ctx.closePath() to connect start and end points.

Colors: set the current color using the strokeStyle and fillStyle properties of the canvas context object
Ex:
ctx.strokeStyle = 'red';
ctx.fillStyle = "#00ff00";
ctx.strokeStyle = "rgb(0, 0, 255)";
ctx.fillStyle = "rgba(0, 0, 255, 0.5)";  where a is alpha channel value between 0 (transparent) and 1 (opaque)

Example: Shadows
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
  </head>
<body onload = init();>
<canvas id="myCanvas" width="400" height =800>
  Your browser does not support the canvas tag.</canvas>
</body>
</html>

var canvas, ctx;
 
function init() {
  canvas = document.getElementById('myCanvas');
  ctx = canvas.getContext('2d');
  
  setShadow();
  
  // first green filled rectangle
  ctx.fillStyle = "#22FFDD"; // rectangle color
  ctx.fillRect(20, 20, 200, 100); 
  
  // second stroked rectangle
  ctx.strokeStyle = "purple"; // rectangle color
  ctx.lineWidth=10;
  ctx.strokeRect(20, 150, 200, 100); 
}

function setShadow() {
   ctx.shadowColor = "Grey";      // color
   ctx.shadowBlur = 20;           // blur level
   ctx.shadowOffsetX = 15;        // horizontal offset
   ctx.shadowOffsetY = 15;        // vertical offset
}

<!-- Animations -->
Before HTML5:
For animation, the setInterval(function, ms) and setTimeout(function, ms) methods were the only solutions. 
Both methods take a function as the first parameter, and a number of milliseconds as the second parameter.
The only difference is that the code provided to setInterval will run every n milliseconds whereas the 
code in setTimeout will run only once after n milliseconds
After HTML5:
The above are now completed by a new method that comes with multiple advantages: the requestAnimationFrame API.

Core example:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Animation</title>
      
    <style>
        #myCanvas {
            border: 1px solid black;
        }
    </style>
    <script>
      var canvas, ctx;
      var rectangleX = 0;
      var colors = ['red', 'blue', 'green'];
      var currentColor = 0;
      var speed = 3;
      function init() {
        // 1 - Get the canvas
        canvas = document.getElementById('myCanvas');

        // 2 - Get the context
        ctx=canvas.getContext('2d');

        // 3 - we can draw
        // Old way: using only setInterval & setTimeout unreliable timing can be imprecise if animate
        // is task-heavy.  Instead, use requestAnimationFrame to achieve 60 fps.
        //setInterval(animate, 100);
        //setTimeout(animate, 100);
        requestAnimationFrame(animate);
        setInterval(changeColor, 1000);
      }
      
      function animate() {
        // - 1 clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 2 - draw a red rectangle
        ctx.fillRect(rectangleX,0,80,100);
        
        // 3 - move the shape
        rectangleX = rectangleX +speed;
        if((rectangleX+80 > 200) || (rectangleX <= 0)){
          speed = -speed;
        }
        
        // Call the animate function again after 100ms
        //setTimeout(animate, 100);   // old way of doing it
        requestAnimationFrame(animate);
      }
      
      function changeColor() {
        ctx.fillStyle= colors[currentColor%3];
        currentColor += 1;
        // Comment next line if you do not want to change the speed at each bounce
        speed += Math.sign(speed)*1;
        console.log("speed = " + speed)
      }
    </script>
    </head>

  <body onload="init();">
    <canvas id="myCanvas" width="200" height="200"> Your browser does not support the canvas tag.</canvas>
  </body>
</html>
