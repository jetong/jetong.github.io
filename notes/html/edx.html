Contents:
Basics (structure, best practices)
Multimedia (audio/video)
Graphics
Animations
Forms (validation, new input types and attributes)
APIs (cache manifest, web storage, local files, geolocation)

<!-- Some best practices -->
Do title pages, use alt for images, web internationalization
<meta charset="utf-i"/>
<html lang="fr">
"type" attribute in link and script tags are optional

Pages have relied too heavily on divs and spans and on CSS and Javascript to apply custom styles and behaviors.  
HTML5 partly addresses this evolution of web pages.
Also helps with accessibility and portability, splitting page content into regions using: 
header, footer, nav, section, article, aside, main

<!-- FlexBox -->
<!DOCTYPE html>
<html>
	<head>
		<style>
			.flex-container {
				display: flex;
				background-color: Blue;
			}
			
			.flex-container > div {
				background-color: #11f1f1;
			  	margin: 10px;
			 	padding: 20px;
				font-size: 30px;
				width:30%;
			}
		</style>
		Contents:
	</head>

	<body>
		<div class="flex-container">
  		<div>1</div>
  		<div>2</div>
  		<div>3</div>  
		</div>
	</body>
</html>


<!-- em -->
CSS note: em unit is a ratio of the current element's font size, or if no font size is defined, it inherits
from the nearest parent.  The font size then becomes a sort of base for the element's children and this 
allows CSS to be modular.  Changing the base font size scales all the other sizes below.

More elaborate example: https://codepen.io/w3devcampus/pen/wKRwbX
<!DOCTYPE html>
<html lang="en">  
<head>
  <meta charset="utf-8">
  <title>HTML5 Semantics and Flexbox</title>
  <style>
    header, footer {
      margin: 0.2em;
      padding: 0.5em;
      background-color: #D2691E;
      text-align: center;
    }  

    /* this corresponds to a div that contains the mid-section: nav, main, aside */
    .row {  
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;
    }    

    nav {
    margin: 0.2em;
	min-height: 8em;
	padding: 0.5em;  
    width: 10%;
    background-color: lightgreen;
    text-align: center;  
    }

    /* main section */
    .column {
	margin: 0.2em;
	min-height: 8em;
	padding: 1em;
	width: 65%;
    background-color: #9df5d7;  
    }

    aside {
	margin: 0.2em;
	min-height: 8em;
	padding: 1em;
	width: 20%;
    background-color: lightBlue;
    }
    a {
      text-decoration: none;
    }
    a:hover {
      color: red;
    }
  </style>
</head>
<body>
  <header>
    <h1>HTML5 Semantics and Flexbox</h1>    
  </header>
  
<div class="row">
  <nav>    
    <h3>Navigate</h3>          
    <strong>Home<br>
    <a href="">Link1</a><br>
    <a href="">Link2</a>
    </strong>
  </nav>

  <main class="column">
  <section>
    <article>
      <h2>
        About This Page
      </h2>
      <p>On this page, I am experimenting with HTML5 semantics and CSS flexbox for a tidy layout.</p>
      <p>On JS Bin, I purposedly includes the stylesheet on the HTML tab (instead of separate CSS tab) for easier code reading for those with small screen.</p>
      <p>The <code>main</code> element is placed within a <code>div</code> element along with <code>nav</code> and <code>aside</code>. I don't know if this is right or wrong (let me know?).</p>
      <p>Navigation links are placed within <code>nav</code>, laid on the left. The <code>main</code> is at the center column (this column). Within it is the main topic (this article).</p>
      <p>The <code>aside</code> element is at the rightmost of the column, I put supplemental information on it.</p>    
    </article>
  </section>
  <section>
    <article>
      <h2>Test This Page!</h2>
      <p>Do test this page by:</p>
        <ul>
          <li>Resizing the browser windows; see if flexbox lives up to its reputation.</li>
          <li>Run HTML Outliner or HeadingsMap (or similar tool) and see if the outline is good. </li>
          <li>Check the markup in this page with W3C Markup validator; see if the markups are good. Paste the URL of this page to the address column. <a href="https://validator.w3.org/" target="_blank">Click here to try!</a>.</li>
          <li>Check the CSS part of this page too! <a href="https://jigsaw.w3.org/css-validator/" target="_blank">Click here!</a></li>
        </ul>
    </article>
  </section>
  </main>  

  <aside>
    <h2>HTML</h2>    
    <p>Stands for HyperText Markup Language. The current standard is HTML5.</p>
    <h2>CSS</h2>
    <p>Stands for Cascaded Style Sheet. The current standard is CSS3.</p>
    <h2>URL</h2>
    <p>Short for Uniform Resource Locator. It is a reference (an address) to a resource on the Internet.</p>
  </aside>
</div>

  <footer>Nov, 2015 @ royray</footer>  
 </body>
</html>
 

<!-- details & summary tags to create simple clickable widget to hide/show contents -->
<!-- The summary element is not supported in Edge/Internet Explorer -->
<details>
  <summary>Copyright 1999-2014.</summary>
  <p> - by Refsnes Data. All Rights Reserved.</p>
</details>

<!-- css to format details & summary -->
summary::-webkit-details-marker {
 color:#FF0000; 
 background:#FFFFFF; 
}

details[open] summary::-webkit-details-marker {
	color:#0000FF;
	background:#00FFFF;
}

<!---------------------------------------->
polyfills - fallback javascript code that emulates an HTML5 feature not yet implemented in certain browsers
http://caniuse.com
http://html5please.com
modernizr on github
Search for the particular HTML5 feature to see browser support and check for fallback script in resources tab

<!---------------------------------------->
<time> tag for flexibility in outputing various date formats for readers while making it 
easier for programs to index date data and allowing search engines and other programs to 
quickly locate and parse them.

<!---------------------------------------->
<mark> for highlighting text

<!---------------------------------------->
Download attribute.
<a href="https://www.somewhere.com/picture.gif" download="pic.gif">Download Picture</a>
Enables ability to force a download rather than navigating to the file.  Downloaded filename can be specified as well.
href attribute is the file source and download is the specified name to save that file as.

<!---------------------------------------->
Translate attribute.
<span translate="no">Linda</span>
Prevent/limit the impact of translation tools such as Google Translate.
This person's name would otherwise be translated into "Pretty" in Spanish.
Any children of the attributed elemented will also inherit the attribute.



<!-- VIDEO EMBEDDING --> 
Old way:
<object>
   <param name="movie" value="http://www.youtube.com/v/9sEI1AUFJKw&hl=en_GB&fs=1&"></param>
   <param name="allowFullScreen"   value="true"></param>
   <param name="allowscriptaccess" value="always"></param>

   <embed src="http://www.youtube.com/v/9sEI1AUFJKw&hl=en_GB&fs=1&"
          type="application/x-shockwave-flash"
          allowscriptaccess="always" allowfullscreen="true"
          width="425" height="344">
   </embed>
</object>

HTML5
<!-- attributes: controls, autoplay, loop.  
     can style using css since <video> is part of the DOM -->
<video id="vid" controls autoplay> 
	<!-- I have three versions of the video encoded with
	     different codecs.  The browser will automatically
	     choose the first one it knows it can play. --> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.webm type=video/webm> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.ogg type=video/ogg> 
	<source src=http://html5doctor.com/demos/video-canvas-magic/video.mp4 type=video/mp4> 
</video> 
<button onclick="playVideo();" style="cursor: pointer;">Play</button>
<button onclick="pauseVideo();" style="cursor: pointer;">Pause</button>
<button onclick="rewindVideo();" style="cursor: pointer;">Back to beginning</button>
<script>
  vid = document.querySelector("#vid");
  function playVideo() { vid.play(); }
  function pauseVideo() { vid.pause(); }
  function rewindVideo() { vid.currentTime = 0; }
</script>

CSS for fullscreen video
body {
  margin:0;
  padding:0;
  overflow:hidden;
}
 
video {
  width:100%;
  height:auto;
}

To detect end of video and do something else (like play another video), listen for 'ended' event
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Sequential Movies</title>
    <script>
      var myVideo;
      var currentVideo = 0;
      var sources = [
        "https://mainline.i3s.unice.fr/mooc/samuraiPizzacat.mp4",
        "http://www.archive.org/download/AnimatedMechanicalArtPiecesAtMit/P1120973_512kb.mp4"
        ];
      // Set the src of the video to the next URL in the playlist
      function loadNextVideo() {
        myVideo.src = sources[currentVideo % sources.length]
        myVideo.load();
        currentVideo++;
      }
      // called by addEventListener
      function loadAndplayNextVideo() {
        console.log("playing " + sources[currentVideo % sources.length])
        loadNextVideo();
        myVideo.play();
      }
      function init(){
        myVideo = document.querySelector("#myVideo");
        // Define a callback function called each time a video ended
        myVideo.addEventListener('ended', loadAndplayNextVideo, false);     // here //
        // Load the first video when the page is loaded.
        loadNextVideo();
      }
    </script>
  </head>
<body onload="init()">
    <video id="myVideo"
      controls>
    </video>
</body>
</html>

For YouTube, Dailymotion, Vimeo, etc, need to embed differently:
(right click on video and select 'copy embed code')
(licensing and royalties prevent certain videos from playing, so this may not always work)
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZH1XOsv8Oyo" frameborder="0" allowfullscreen></iframe>

Example using CSS3 transformations(zoom, rotate, etc) on video: https://jsbin.com/lunosev/1/edit?html,css,js,output
Example using filters in real time: https://jsbin.com/siduxad/edit?html,output
Example handling video errors and logs: https://jsbin.com/becaref/3/edit?html,output
Example displaying buffer progress indicator: https://jsbin.com/xororol/3/edit?html,output

Adding closed captions and subtitles using <track>:
http://www.universalsubtitles.org, also known as http://www.amara.org.  Allow uploading
YouTube video and offers online editor.


<!------ AUDIO ------>
<audio controls="controls">
   <source src="https://mainline.i3s.unice.fr/mooc/horse.ogg" type="audio/ogg" />
   <source src="https://mainline.i3s.unice.fr/mooc/horse.mp3" type="audio/mp3" />
      Your browser does not support the audio element.
      Download the audio/video in
   <a href="https://mainline.i3s.unice.fr/mooc/horse.ogg">OGG</a>
   or <a href="https://mainline.i3s.unice.fr/mooc/horse.mp3">MP3</a>
   format.
</audio>


<!-- GRAPHICS using <canvas> -->
Ensure page is loaded before running js using one of the following methods: 

1) <body onload="init();">
2) in script, use window.onload = function() { get canvas object, etc };
3) place <script></script> tags at the very end
4) use defer

Steps:
1.  Declare the canvas, remembering to add an id attribute, and fallback content:  
    <canvas id="myCanvas" width="200" height="200">
      ...fallback content...
    </canvas>
2.  Get a reference to the canvas in a JavaScript variable using the DOM API: 
    var canvas=document.getElementById('myCanvas');
3.  Get the context for drawing in that canvas:  
    var ctx=canvas.getContext('2d');
4.  Specify some drawing properties (optional):  
    ctx.fillStyle='#FF0000';
5.  Draw some shapes: 
    ctx.fillRect(0,0,80,100);

Example
<!DOCTYPE html>
<html lang="en">
 <head>
   <title>Drawing principales unité</title>
   <meta charset="utf-8"/>
   <style>
       #myCanvas {
           border: 1px solid black;
       }
   </style>
   <script>
     var canvas, ctx;
   
     function init() {
       // 1 - Get the canvas
       canvas = document.getElementById('myCanvas');
       // 2 - Get the context
       ctx=canvas.getContext('2d');
       // Optionally do transformations to the context before drawing
       ctx.translate(100, 100);
       ctx.rotate(Math.PI/4);
       ctx.scale(0.5, 0.5);
       // 3 - we can draw
       drawSomething();
     }
  
     function drawSomething() {
       // draw a red rectangle, line width=3 pixels
       ctx.lineWidth=3;
       ctx.strokeStyle='red';
       ctx.strokeRect(10,10,80,100);
     }
   </script>
 </head>
<body onload="init();">
    <canvas id="myCanvas" width="200" height="200">
            Your browser does not support the canvas tag.
    </canvas>
</body>
</html>

There are two methods for saving and restoring the context properties: ctx.save() and ctx.restore().
Best practice: 
save the context at the beginning of any function that changes the context, then restore it at the end of the function!

To draw an image from a file source, make sure web page loaded, and make sure image is loaded in memory first:
<script>
  // wait for page to load
  window.onload = function () {
    var canvas = document.getElementById("myCanvas");
    var context = canvas.getContext("2d");
    var imageObj = new Image();
    // wait for image to load into memory before drawing
    imageObj.onload = function () {
      context.drawImage(imageObj, 0, 0);
    };
    // Calls the imageObj.onload function asynchronously, once loaded to memory
    imageObj.src = "http://www.w3.org/html/logo/downloads/HTML5_Logo_512.png";
  };
</script>

Path mode = fill a buffer then execute all buffered orders with one go to enable optimization and parallelism
Call drawing methods that work in path mode, for example call ctx.rect(...) instead of ctx.strokeRect(...) or ctx.fillRect(...)
Call ctx.stroke() or ctx.fill() to draw the buffer's contents,
Beware that the buffer is never emptied, two consecutive calls to ctx.stroke() will draw the buffer contents twice! Instead, use ctx.beginPath() to empty it if needed.
Use ctx.moveTo(x,y) and ctx.lineTo(x,y) to draw lines
ctx.closePath() to connect start and end points.

Colors: set the current color using the strokeStyle and fillStyle properties of the canvas context object
Ex:
ctx.strokeStyle = 'red';
ctx.fillStyle = "#00ff00";
ctx.strokeStyle = "rgb(0, 0, 255)";
ctx.fillStyle = "rgba(0, 0, 255, 0.5)";  where a is alpha channel value between 0 (transparent) and 1 (opaque)

Example: Shadows
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
  </head>
<body onload = init();>
<canvas id="myCanvas" width="400" height =800>
  Your browser does not support the canvas tag.</canvas>
</body>
</html>

var canvas, ctx;
 
function init() {
  canvas = document.getElementById('myCanvas');
  ctx = canvas.getContext('2d');
  
  setShadow();
  
  // first green filled rectangle
  ctx.fillStyle = "#22FFDD"; // rectangle color
  ctx.fillRect(20, 20, 200, 100); 
  
  // second stroked rectangle
  ctx.strokeStyle = "purple"; // rectangle color
  ctx.lineWidth=10;
  ctx.strokeRect(20, 150, 200, 100); 
}

function setShadow() {
   ctx.shadowColor = "Grey";      // color
   ctx.shadowBlur = 20;           // blur level
   ctx.shadowOffsetX = 15;        // horizontal offset
   ctx.shadowOffsetY = 15;        // vertical offset
}


<!-- ANIMATIONS -->
Before HTML5:
For animation, the setInterval(function, ms) and setTimeout(function, ms) methods were the only solutions. 
Both methods take a function as the first parameter, and a number of milliseconds as the second parameter.
The only difference is that the code provided to setInterval will run every n milliseconds whereas the 
code in setTimeout will run only once after n milliseconds
After HTML5:
The above are now completed by a new method that comes with multiple advantages: the requestAnimationFrame API.

Core example:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Animation</title>
      
    <style>
        #myCanvas {
            border: 1px solid black;
        }
    </style>
    <script>
      var canvas, ctx;
      var rectangleX = 0;
      var colors = ['red', 'blue', 'green'];
      var currentColor = 0;
      var speed = 3;

      function init() {
        // 1 - Get the canvas
        canvas = document.getElementById('myCanvas');
        // 2 - Get the context
        ctx=canvas.getContext('2d');

        // 3 - we can draw
        // Old way: using only setInterval & setTimeout unreliable timing can be imprecise if animate
        // is task-heavy.  Instead, use requestAnimationFrame to achieve 60 fps.
        //setInterval(animate, 100);
        //setTimeout(animate, 100);

        requestAnimationFrame(animate);
        // use setInterval to update the object state (changing color/speed) rather than animating directly
        setInterval(changeColor, 1000);
      }
      
      function animate() {
        // 1 - clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 2 - draw a red rectangle
        ctx.fillRect(rectangleX,0,80,100);
        // 3 - move the shape
        rectangleX = rectangleX +speed;
        if((rectangleX+80 > 200) || (rectangleX <= 0)){
          speed = -speed;
        }
        
        // Call the animate function again after 100ms
        //setTimeout(animate, 100);   // old way of doing it
        requestAnimationFrame(animate);
      }
      
      function changeColor() {
        ctx.fillStyle= colors[currentColor%3];
        currentColor += 1;
        // Comment next line if you do not want to change the speed at each bounce
        speed += Math.sign(speed)*1;
        console.log("speed = " + speed)
      }
    </script>
    </head>

  <body onload="init();">
    <canvas id="myCanvas" width="200" height="200"> Your browser does not support the canvas tag.</canvas>
  </body>
</html>

Handling events: Target a DOM element with getElementById() and register a listener to it with addEventListener().
Define a callback associated with the event listener which would handle the event.

Example: listening to key event only when canvas has focus
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
<style type="text/css">
    canvas { 
      border:1px solid black;
    }
</style>
</head>
<body onload="init();">
  This example shows how to handle key events in a canvas by adding a key listener to the canvas object. 
  <p>If you don't want a border to appear when you click on the canvas, set its style to outline: none.</p>

  <canvas id="myCanvas" width="350" tabindex="1" height="200">
  </canvas>
  
  <script>
    var canvas;
    
    function init() {
      canvas=document.getElementById('myCanvas');
      // This will work only if the canvas has the focus.
      // To register keypress from anywhere on page, use window.addEventListener()
      canvas.addEventListener('keydown', handleKeydown, false);
      // use 'false' explicitly for backwards-compatibility of older browsers to propagate the event 
      // to the element's ancestors using bubbling phase.
      // https://stackoverflow.com/questions/17564323/what-does-the-third-parameter-false-indicate-in-document-addeventlistenerdev
      
      // We can start with focus initially on the canvas
      // canvas.focus();
    }
  
    function handleKeydown(e){
       alert('keycode: '+e.keyCode);
       return false;
    };
  </script>
</body>
</html>

The default coordinates of the mouse are its "window coordinates".  To get mouse position relative to canvas use
getBoundingClientRect() to adjust origin.
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>JS Bin</title>

      <style>
        body {
          margin: 20px;
          padding: 0px;
        }
        canvas {
          border:1px solid black
        }
      </style>

  </head>

  <body>
    This is a canvas:<p></p>
    <canvas id="myCanvas" width="578" height="200"></canvas>
    <script>
      var canvas, ctx, mousePos, mouseButton;
      
      window.onload = function init() {
          canvas = document.getElementById('myCanvas');
          ctx = canvas.getContext('2d');
      
          canvas.addEventListener('mousemove', function (evt) {
              mousePos = getMousePos(canvas, evt);
              var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
              writeMessage(canvas, message);
          }, false);
      
            canvas.addEventListener('mousedown', function (evt) {
              mouseButton = evt.button;
              var message = "Mouse button " + evt.button + " down at position: " + mousePos.x + ',' + mousePos.y;
              writeMessage(canvas, message);
          }, false);
      
          canvas.addEventListener('mouseup', function (evt) {
              var message = "Mouse up at position: " + mousePos.x + ',' + mousePos.y;
              writeMessage(canvas, message);
          }, false);
      };
      
      function writeMessage(canvas, message) {
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = '18pt Calibri';
          ctx.fillStyle = 'black';
          ctx.fillText(message, 10, 25);
          ctx.restore();
      }
      
      function getMousePos(canvas, evt) {
          // necessary to take into account CSS boudaries
          var rect = canvas.getBoundingClientRect();
          return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
          };
      }
    </script>
  </body>
</html

Responsive Canvas: handling canvas resizing
Resizing a canvas can be tricky if we don't know a few rules that might not be easily guessed:
Changing the width or height property of a canvas in JavaScript erases its content and resets its context,
Using percentages (%) in the CSS width and height properties of a canvas does not change its number of pixels/resolution. Instead, it scales the existing pixels without erasing the content, giving a blurry effect when a canvas becomes larger, for example.
GOOD PRACTICE: never use CSS percentages on a canvas width or height!
The trick is to embed the canvas in a div and use CSS percentages on the div, then resize the canvas to match
the div size(contents will be erased automatically) and redraw.
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
        <style>
            #parentDiv {
                width:100%;
                height:50%;
                margin-right: 10px;
                border: 1px solid red;
            }

            canvas {
                border: 2px solid black;
            }
        </style>
        <script>
            var canvas, divcanvas, context;

            function init() {
                canvas = document.querySelector("#mycanvas");
                ctx = canvas.getContext('2d');
                divcanvas = document.querySelector("#parentDiv");

                // Let's adjust the canvas size to the parent size at start (the div)
                //resizeCanvasAccordingToParentSize();

                drawDiagonals();

                // Add an event listener for the window resize event
                window.addEventListener('resize', resizeCanvasAccordingToParentSize, false);
            }

            function resizeCanvasAccordingToParentSize() {
                // adjust canvas size
                canvas.width = divcanvas.clientWidth;
                canvas.height = divcanvas.clientHeight;
                drawDiagonals();
            }

            function drawDiagonals() {
                // draw two diagonals
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.moveTo(0, canvas.height, canvas.width, 0);
                ctx.lineTo(canvas.width, 0);
                ctx.stroke();
            }
        </script>
    </head>
    <body onload="init();">
        Try resizing the window... You can also change the percentages in the CSS
        <p><p><p>
        <div id="parentDiv">
            <canvas id="mycanvas" width="100" height="100"></canvas>
        </div> 
    </body>
</html>

Example: Collision checking
// Inits
window.onload = function init() {
  var game = new GF();
  game.start();
};


// GAME FRAMEWORK STARTS HERE
var GF = function(){
    // Vars relative to the canvas
    var canvas, ctx, w, h; 

    // vars for counting frames/s, used by the measureFPS function
    var frameCount = 0;
    var lastTime;
    var fpsContainer;
    var fps; 
  
    // vars for handling inputs
    var inputStates = {};
  
    // The monster !
    var monster = {
      x:80,
      y:80,
      width: 100,
      height : 100,
      speed:1,
       boundingCircleRadius: 70    
    };
  
    var player = {
      x:0,
      y:0,
      boundingCircleRadius: 20    
    };
  
    var measureFPS = function(newTime){
      
         // test for the very first invocation
         if(lastTime === undefined) {
           lastTime = newTime; 
           return;
         }
      
        //calculate the difference between last & current frame
        var diffTime = newTime - lastTime; 

        if (diffTime >= 1000) {
            fps = frameCount;    
            frameCount = 0;
            lastTime = newTime;
        }

        //and display it in an element we appended to the 
        // document in the start() function
       fpsContainer.innerHTML = 'FPS: ' + fps; 
       frameCount++;
    };
  
     // clears the canvas content
     function clearCanvas() {
       ctx.clearRect(0, 0, w, h);
     }
  
     // Functions for drawing the monster and maybe other objects
     function drawMyMonster() {
       // draw a big monster !
       // head
   
       // save the context
       ctx.save();
  
       // translate the coordinate system, draw relative to it
       ctx.translate(monster.x-monster.width/2, monster.y-monster.height/2);
  
       // (0, 0) is the top left corner of the monster.
       ctx.strokeRect(0, 0, monster.width, monster.height);
  
       // eyes
       ctx.fillRect(20, 20, 10, 10);
       ctx.fillRect(65, 20, 10, 10);
  
       // nose
       ctx.strokeRect(45, 40, 10, 40);
  
       // mouth
       ctx.strokeRect(35, 84, 30, 10);
  
       // teeth
       ctx.fillRect(38, 84, 10, 10);
       ctx.fillRect(52, 84, 10, 10);
       
       // Draw bounding circle
       ctx.beginPath();
       ctx.arc(50, 50, monster.boundingCircleRadius, 0, 2*Math.PI);
       ctx.stroke();
  
      // restore the context
      ctx.restore(); 
    }
  
    var mainLoop = function(time){
        //main function, called each frame 
        measureFPS(time);
      
        // Clear the canvas
        clearCanvas();
        
        // draw the monster
        drawMyMonster();
      
        // Check inputs and move the monster
        updateMonsterPosition();
      
        updatePlayer();
      
        checkCollisions();
 
        // call the animation loop every 1/60th of second
        requestAnimationFrame(mainLoop);
    };
  

  function updatePlayer() {
    // The player is just a circle, drawn at the mouse position
    // Just to test circle/circle collision.
    
    if(inputStates.mousePos) {
       player.x = inputStates.mousePos.x;
       player.y = inputStates.mousePos.y;
       ctx.beginPath();
       ctx.arc(player.x, player.y, player.boundingCircleRadius, 0, 2*Math.PI);
       ctx.stroke();
     }
  }
  
  function checkCollisions() {
    if(circleCollide(player.x, player.y, player.boundingCircleRadius, monster.x, monster.y, monster.boundingCircleRadius)) {
      ctx.fillText("Collision", 150, 20);
      ctx.strokeStyle = ctx.fillStyle = 'red';
    } else {
      ctx.fillText("No collision", 150, 20);
      ctx.strokeStyle = ctx.fillStyle = 'black';
    }
  }
  

function circleCollideNonOptimised(x1, y1, r1, x2, y2, r2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  var distance = Math.sqrt(dx * dx + dy * dy);

  return (distance < r1 + r2);  
}

function circleCollide(x1, y1, r1, x2, y2, r2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return ((dx * dx + dy * dy) < (r1 + r2)*(r1+r2));  
}
   
    function updateMonsterPosition() {
      monster.speedX = monster.speedY = 0;
        // check inputStates
        if (inputStates.left) {
            ctx.fillText("left", 150, 20);
            monster.speedX = -monster.speed;
        }
        if (inputStates.up) {
            ctx.fillText("up", 150, 40);
           monster.speedY = -monster.speed;
        }
       if (inputStates.right) {
            ctx.fillText("right", 150, 60);
            monster.speedX = monster.speed;
        }
        if (inputStates.down) {
            ctx.fillText("down", 150, 80);
            monster.speedY = monster.speed;
        } 
        if (inputStates.space) {
            ctx.fillText("space bar", 140, 100);
        }
        if (inputStates.mousePos) { 
            ctx.fillText("x = " + inputStates.mousePos.x + " y = " + inputStates.mousePos.y, 5, 200);
        }
       if (inputStates.mousedown) { 
            ctx.fillText("mousedown b" + inputStates.mouseButton, 5, 180);
            monster.speed = 5;
        } else {
          // mouse up
          monster.speed = 1;
        }
      
        monster.x += monster.speedX;
        monster.y += monster.speedY;
      
    }
  
  
    function getMousePos(evt) {
        // necessary to take into account CSS boudaries
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }
      
    var start = function(){
        // adds a div for displaying the fps value
        fpsContainer = document.createElement('div');
        document.body.appendChild(fpsContainer);
      
        // Canvas, context etc.
        canvas = document.querySelector("#myCanvas");
  
        // often useful
        w = canvas.width; 
        h = canvas.height;  
  
        // important, we will draw with this object
        ctx = canvas.getContext('2d');
        // default police for text
        ctx.font="20px Arial";
      
       //add the listener to the main, window object, and update the states
      window.addEventListener('keydown', function(event){
          if (event.keyCode === 37) {
             inputStates.left = true;
          } else if (event.keyCode === 38) {
             inputStates.up = true;
          } else if (event.keyCode === 39) {
             inputStates.right = true;
          } else if (event.keyCode === 40) {
             inputStates.down = true;
          }  else if (event.keyCode === 32) {
             inputStates.space = true;
          }
      }, false);

      //if the key will be released, change the states object 
      window.addEventListener('keyup', function(event){
          if (event.keyCode === 37) {
             inputStates.left = false;
          } else if (event.keyCode === 38) {
             inputStates.up = false;
          } else if (event.keyCode === 39) {
             inputStates.right = false;
          } else if (event.keyCode === 40) {
             inputStates.down = false;
          } else if (event.keyCode === 32) {
             inputStates.space = false;
          }
      }, false);
      
      // Mouse event listeners
      canvas.addEventListener('mousemove', function (evt) {
          inputStates.mousePos = getMousePos(evt);
      }, false);

      canvas.addEventListener('mousedown', function (evt) {
            inputStates.mousedown = true;
            inputStates.mouseButton = evt.button;
      }, false);

      canvas.addEventListener('mouseup', function (evt) {
          inputStates.mousedown = false;
      }, false);      


        // start the animation
        requestAnimationFrame(mainLoop);
    };

    //our GameFramework returns a public API visible from outside its scope
    return {
        start: start
    };
};

Example: Sprite-based animation
var spritesWoman = {
	// autant de sprites que de directions,
	// Chaque sprite dans ce tableau contient n sous images
	sprites : []
};

DIR_S= 0;
DIR_SW = 1;
DIR_W= 2;
DIR_NW = 3;
DIR_N = 4;
DIR_NE  = 5;
DIR_E = 6;
DIR_SE = 7;

var dir = DIR_S;

var moving = false;
var x = 0;
var y = 0;

var scale = 1;

function mainLoop(timestamp) {

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (moving) {
		switch(dir) {
		case DIR_E:
		    x += 6;
		    break;
		case DIR_W:
		    x -= 6;
		    break;
		case DIR_N:
		    y -= 6;
		    break;
		case DIR_S:
		    y += 6;
		}

		scale = 1 + 2 * (y / canvas.height);
    }

    if(!moving) {
        spritesWoman[dir].render(x, y, scale);
	} else {
		spritesWoman[dir].renderMoving(x, y, scale);
	}

	// recall mainLoop every 1/60th of second
    requestAnimationFrame(mainLoop);
}


window.onload = function() {	  
    canvas = document.getElementById("canvas");
    ctx = document.getElementById("canvas").getContext("2d");
  
    // load the spritesheet
    spritesheet = new Image();
    spritesheet.src="http://i.imgur.com/3VesWqx.png";
    spritesheet.onload = function() {
      
    // info about spritesheet
	var SPRITE_WIDTH = 48;
	var SPRITE_HEIGHT = 92;
	var NB_DIRECTIONS = 8;
	var NB_FRAMES_PER_POSTURE = 13;

    initSprites(spritesheet, SPRITE_WIDTH, SPRITE_HEIGHT, 
    			NB_DIRECTIONS, NB_FRAMES_PER_POSTURE);
      
      requestAnimationFrame(mainLoop);
    };
    
};

document.onkeydown = function(e) {
    e = e || window.event;

    switch (e.keyCode) {
    case 38:	
	dir = DIR_N;
	moving = true;
	break;
    case 37:
	dir = DIR_W;
	moving = true;
	break;	
    case 39:	
	dir = DIR_E;
	moving = true;
	break;
    case 40:
	dir = DIR_S;
	moving = true;
	break;
    }

};

document.onkeyup = function(e) {
    e = e || window.event;

	moving = false;
};

function SpriteImage(img, x, y, width, height) {
	this.img = img;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
  
    // xPos et yPos = position où dessiner le sprite,
    // scale = s'il faut rescaler.
    this.render = function(xPos, yPos, scale) {
          ctx.drawImage(this.img, 
		  this.x, this.y, 
		  this.width, this.height, 
		  xPos, yPos, 
		  this.width*scale, this.height*scale);
    };
}

function Sprite(spritesheet, x, y, width, height, nbImages, nbFramesOfAnimationBetweenRedraws) {
	this.spriteImages = [];
    this.currentFrame = 0;
    this.nbFrames = nbImages;
    this.nbTicksBetweenRedraws = nbFramesOfAnimationBetweenRedraws;
    this.nbCurrentTicks=0;

    // on parcour la ligne de l'image où se trouve les imagettes
    // d'animation
	for(var i = 0; i < nbImages; i++) {
		// we extract the subimage
		this.spriteImages[i] = new SpriteImage(spritesheet, x+i*width, y, width, height);
	}

	this.renderMoving = function(x, y, scale) {
		// renders animated sprite, changed every nbTicksBetweenRedraws
		// the frame number
		
		// draw the sprite with the current image
		this.spriteImages[this.currentFrame].render(x, y, scale);

		// increment the number of ticks of animation 
		this.nbCurrentTicks++;

		if(this.nbCurrentTicks > this.nbTicksBetweenRedraws) {
			// enough time elapsed, let's go to the next image
			this.currentFrame++;
			if(this.currentFrame == this.nbFrames) {
				this.currentFrame=0;
			}
			this.nbCurrentTicks = 0;
		}
	};
	this.render = function(x, y, scale) {
		// draws always frame 0, static position
		this.spriteImages[0].render(x, y, scale);
	};
}
function initSprites(spritesheet, spriteWidth, spriteHeight, nbLinesOfSprites, 
						  nbSpritesPerLine) { 	
    // on parcour l'image et pour chaque ligne (correspondant à une direction)
    // on extrait un sprite
   	for(var i= 0; i < nbLinesOfSprites; i++) {
   		var yLineForCurrentDir = i*spriteHeight;

   		var sprite = new Sprite(spritesheet, 0, yLineForCurrentDir, 
   								spriteWidth, spriteHeight, 
   								nbSpritesPerLine,
   								3); // draw every 1s
   		spritesWoman[i] = sprite;
   	}
}


<!-- Using GUI input elements(widgets) to drive graphics in animations & chart displays
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
  </head>
<body onload="init()">
  <canvas id="canvas" width="400" height="400" style="border:solid 2px black"></canvas>  
  <ul id="sliders"></ul>
</body> 
</html>

var canvas;
var context;

// Size of the histogram
var width = 150, height=150;
// The origin, bottom left corner, relative to the origin in the canvas
var x = 40, y = 190; 

// Data to be visualized
var values = [1, 10, 2, 7, 9, 2, 34, 100, 12, 14, 19];

function init() {
    canvas = document.getElementById('canvas'); 
    context = canvas.getContext('2d'); 
  
    var list =  document.getElementById('sliders'); 
  
    // Create the sliders for changing the values.
    var max = getMax(values);
  
    for (i=0; i < values.length; i++) {
      var input = document.createElement('input');
      var li = document.createElement('li');
      var label = document.createElement('label');
      label.setAttribute('for', 'id'+i);
      label.textContent = 'value' + i + ' ';
      
      li.appendChild(label); 
      
      input.setAttribute('type', 'range');
      input.setAttribute('id', 'id' + i);
      // Set their value and max attributes correctly
      input.setAttribute('max', max);
      input.value = values[i]; 
      // Add an onchange event listener and pass the
      // index of the slider to the callback
      input.setAttribute('oninput', 'changeValue(' + i + ')');
      li.appendChild(input);
      
      list.appendChild(li);
    }
 
    makeHistogram(x, y, 
                  width, height, 
                  values);  
  // center of pie x and y, radius, values
  makePieChart(300, 100, 90, values); 
  
  // Draw broken lines chart
  makeBrokenLines(40, 370, width, height, values);
}

// callback for slider onchange events. 
function changeValue(index) {
    var value = document.getElementById("id"+index).value; 
  
    // put the slider value in the values array
    values[parseInt(index)] = parseInt(value); 
  
    // clear the canvas
    context.clearRect(0,0, canvas.width, canvas.height); 
    
    // redraw the charts
    makeHistogram(x, y, width, height, values);  
    makePieChart(300, 100, 90, values); 
    makeBrokenLines(40, 370, width, height, values);
}           
// returns the max from the elements of the values array.
function getMax(values) {
    var maxValue = 0;
  
    for (i=0; i<values.length; i++) {
        if (maxValue < values[i])
            maxValue = values[i];
    }
  return maxValue;
}

function drawAxis(width, height,  values, maxValue) {
	// remember: we have the origin of the coordinate system at bottom left
	// Y values above will be negative
	  
    context.strokeStyle = "black"; //We draw in black the outline.
    context.fillStyle = "black"; //We fill in black.
  
    //We define the vertical step unit. Is it 10 ? 20 ? 100 ? 1000 ? Depending on the
    // max unit value, we decide how the steps will be for the ticks
    var unit = 1; 
    while (maxValue / (unit*10) > 1) {
        unit *= 10; 
    }
  
   //We define the highest vertical step.
    var yMaxOnAxis = parseInt(maxValue) / unit;   
  
    // Everything is in a path, all drawing orders will be drawn by a final call
    // to context.stroke() at the end of the function.
    context.beginPath(); //Begin a new path.
  
    // Draw the axis' lines
    context.moveTo(0, 0); //We place the cursor to origin.
    context.lineTo(0, -height); //We draw the vertical line.
    context.moveTo(0, 0); //We place the cursor to origin.
    context.lineTo(width, 0); //We draw the horizontal line.


    // ticks/labels on the vertical line
    context.textAlign = "left";

    for (i=0; i <= yMaxOnAxis; i++) {
        // move to the next graduation. the y value is negative due to
        // the change of the origin by a call to translate(x,y) in the drawHistogram
        // function.
        context.moveTo(0, -height / yMaxOnAxis * i );
      
        // draw an horizontal line, 5 pixels long, on the left of the axis
        context.lineTo(-5, -height / yMaxOnAxis * i ); 
      
        // write the tick value, 25 pixels on the left of the axis
        context.fillText(i*unit, -25, -height / yMaxOnAxis * i ); 
    }

    // Ticks/labels on the horizontal line
    var counter = 0; 
    // text centered below the tick
    context.textAlign = "center"; 

  
    // graduation on the horizontal line.
    var rectanglesWidth = width / values.length;
    
    for (i=0; i <= values.length; i++) {
    	  // Move to the next horizontal position of the tick
        context.moveTo(i*rectanglesWidth , 0); 
        // draw a vertical line 5 pixels long: the tick
        context.lineTo(i*rectanglesWidth , 5); 
        // write tick label  15 pixels below the tick
        context.fillText(i, i*rectanglesWidth , 15); 
        counter++;
    }
    // Draw everything in the path
    context.stroke(); 
    
}

// MakeHistogram building a bar plot. x, y is the bottom left position of the
// histogram. Easier to reason with this coordonate system
function makeHistogram(x, y, width, height, values) {
    context.save();
    // Change the origin at bottom left. If we draw "above", Y values will be negative.
    // y=0 is the horizontal line at bottom
    context.translate(x, y);
    
    // Compute the max of the values array
    var maxValue = getMax(values);
  
    // step in pixels between two horizontal values for bar plot.
    var rectWidth = width / parseFloat(values.length); 

    // step in pixels between two vertical values for bar plot.
    var vStep = -height / parseFloat(maxValue); 
   
    //Set fill color to red and stroke color to black.
    context.fillStyle = "red"; 
    context.strokeStyle = "black";
 
    // Draw the histogram rectangles
    for(i=0; i < values.length; i++) {       
        //We draw a filled red rectangle to represent the current value.
        context.fillRect(i * rectWidth, 0, 
                         rectWidth, vStep * values[i]); 
      
       //We draw the outline of rectangle.
        context.strokeRect(i * rectWidth, 0, 
                           rectWidth, vStep * values[i]); 
    }
  
  // draw the axis
  drawAxis(width, height, values, maxValue); 
  
  context.restore();
}

//makePieChart draw a circle graph with values table.
function makePieChart(cx, cy, radius, values) {
  context.save();
  
    // Compute the sum of all values
    var sum=0;
    for(var n=0; n < values.length; n++) {
      sum += values[n];
    }
  
    //Initialization of red green blue colors.
    var red = 0;
    var green = 0;
    var blue = 0;

  //starting and ending angles of each pie section
    var startingAngle = 0; 
    var endAngle = 0; 
   //The percentage the current value represents, compare to the total,
  // we are in a closed circle, the sum is 100%
    var percentage;

  //We draw in grey the outline of the section.
  context.strokeStyle = "grey"; 
  
  // Draw the pie chart, clockwise, à la HTML5
  //for (var i=values.length-1; i> 0; i--) { // for ccw display 
  for(var i = 0; i < values.length; i++) {
        context.beginPath(); //Begin a new path.

        // We change the colors depending on the i-value. Just a trick based
        // on the modulo. Will produce different colors for the pie sections
        switch (i%3) {
            case 0: //If i modulo 3 equals 0:
                red += 80; //We add red.
                break;
            case 1: //If i modulo 3 equals 1:
                green += 80; //We add green.
                break;
            case 2: //If i modulo 3 equals 2:
                blue += 80; //We add blue.
                break;
            default: //If there is an error.
                alert("we have encountered an error");
                return ; //and we stop makePieChart.
        }
        context.fillStyle = "rgb(" + red + "," + green + "," + blue +")"; 
    
        // percentage of the circle for current section, will give the angles
        percentage = values[i] / parseFloat(sum); 
        endAngle = startingAngle + Math.PI*2*percentage; 

        // draw an arc between starting angle and end angle.
        context.arc(cx, cy, radius, startingAngle, endAngle); 
       // draw a line between end angle and center of circle.
        context.lineTo(cx, cy); 
    
        //The next starting angle is the current end angle.
        startingAngle = endAngle; 

        context.fill();      // draw pie section
        context.stroke();    // draw the outline.
        context.closePath(); // Close the path.
      
        context.restore();
    }
}
  
// draw a broken line chart
function makeBrokenLines(x, y, width, height, values) {
    context.save();
    // Move origin of the coordinate system at x, y, bottom left corner
    context.translate(x, y);
  
    var maxValue = getMax(values);
  
    // distance between two horizontal values, in pixels
    var hStep = width / parseFloat(values.length); 
  
    // step between two vertical values, in pixels
    var vStep = -height / parseFloat(maxValue); 

    // set fill color to black, for drawing the circle plots
    context.fillStyle = "black"; 
    // thickness of the lines
    context. lineWidth = 1; 
  
    // set the cursor to origin.
    context.moveTo(0 , 0); 

    // All lines are drawn into a path
    context.beginPath();
    for(i=0; i<values.length; i++) { 
        context.lineTo(i * hStep, vStep * values[i]);        
    }
    context.stroke(); // draw the path with all the lines

    // Draw the filled black circles at each coordinate of the value
    for(i=0; i<values.length; i++) { 
        context.beginPath(); 
        context.arc(i * hStep, vStep * values[i], 3, 0, 2*Math.PI); 
        context.fill(); //We fill all circles.
    }
  // draw the X and Y axis
  drawAxis(width, height, values, maxValue); 
  
  context.restore();
}


<!----- FORMS ------>
Explore: HTML5 client side validation, input tags and attributes.
Form example using lists: https://jsbin.com/sivula/edit?html,css,js,output
Form example using fieldset/legend structure: http://dev.dhc3.intrasoft-intl.com/html5/philipbkemp/forum.html

Basic Example:
(match the label's 'for' attr with the input's 'id' attr.  Good practice for accessibility and
clicking on label selects the associated input element in the form)
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Form example</title>
</head>
<body>
<form id="myForm">
  <fieldset>
    <legend>Personal informations</legend>
    
    <!-- inputs come with some basic validation depending on the specfied type,
         and CSS can respond by using input:valid or input:invalid (see CSS below). -->
    <label for="firstName">First name:</label>
    <input type="text" id="firstName" required name="firstName">
    
    <br>
    <label for="lastName">Last name:</label>
    <input type="text" id="lastName" required name="lastName">
    
    <br>
    <label for="email">Email:</label>
    <input type="email" id="email" required name="email">
    
    <br>
    <label for="age">Age:</label>
    <input type="number" min=0 max=120  step=5 id="age" required name="age">
 
    <br>
    <label for="date">Birth date:</label>
    <input type="date"  id="date" required name="date">
  </fieldset>
  
  <button>Submit form</button>
  </form>
</body>
</html>

CSS
fieldset {
  padding:10px;
  border-radius:10px;   
}

label {
  display:inline-block;  /* block: each label contained in it's own "paragraph".  
                            inline: lets us put the labels inline right next to the associated input boxes */
  margin-bottom:10px;    /* specify amount of margin between label blocks */
}

/* This setup lets us align the input boxes regardless of the character length of our labels */
input {
  float:right;
  margin-right:70px;
  width:150px;
}

/* change the input box background color according to the data validation */
input:invalid {
  background-color:pink;
}

input:valid {
  background-color:lightgreen;
}


<!-- 13 new input types (typically used within forms) -->
HTML4: button, checkbox, file, hidden, image, password, radio, reset, submit, text.
HTML5: color, email, number, range, search, tel, url, and 5 variants for choosing dates:
       date, datetime, datetime-local, month, time, week.
Browsers providing native implementation will give boost to performance and reduce size of embedded JS.

Example: change background color using color picker
<!DOCTYPE html>
<html lang="en"><head></head>
<body>
  Select a color : <input type="color" id="colorChooser"/>
  <script>
     var colorInputField = document.querySelector("#colorChooser");
     colorInputField.addEventListener('input', function(evt) {
          document.body.style.backgroundColor = this.value;
      }, false);
</script>
</body>
</html>

Example: limit user's available color options.  Use datalist with id matching the list attr of input.
Datalist good for linking a list of choices to an input element.
<input type="color" value="#333333" list="colors">
<datalist id="colors">
     <option>#0000FF</option>
     <option>#00FF00</option>
     <option>#FF0000</option>
</datalist>

Example: color picker polyfill - spectrum.js  The downsides to this color picker: it's appearance is often
dependent on browser and OS, the location where the dialog window will appear can't be controlled.  W3C suggests
using Web Components instead.
Spectrum example:
https://jsbin.com/wibekaditi/edit?html,output
Add these lines between head tags:
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.7.0/spectrum.min.js"></script>
<link rel="stylesheet" type="text/css"
      href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.6.1/spectrum.min.css">
or
Download the spectrum.js library and reference directly:
<!doctype html>
<html lang="en">
<head>
<title>Spectrum polyfill example, for input type=color</title>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../spectrum.css">
<script type="text/javascript" src="../docs/jquery-1.9.1.js"></script>
<script type="text/javascript" src="../spectrum.js"></script>
</head>
<body>
     <input type="color" onchange="alert(this.value);"></p>
</body>
</html>

<!-- Date input -->
<input type="date"
    id="birthdayParty"
    value="2015-06-20"
    min="2015-06-20"
    max="2015-06-30"
    step="7">

using <datalist> to specify which dates possible options.
<input type="date"
    id="birthdayParty"
    list="birthdayPartyPossibleDates"
    value="2015-06-20">
<datalist id="birthdayPartyPossibleDates">
     <option label="Best for me">2015-06-20</option>
     <option label="Ok for me too ">2015-06-27</option>
     <option label="This one is a sunday, hmmm">2015-06-28</option>
</datalist>

Listening to date input event
<input type="date" id="date" />
...
<script>
  var field = document.querySelector("#date");
  field.oninput = function(evt) {
    var date = this.value;
    pickedDate.innerHTML = "<b>"+date+"</b>";
  }
</script>


Other Input Types:
<input type="email">, <input type="tel">, <input type="URL"> and <input type="search">

Input type: "tel" (for smartphones and tablets, a keyboard layout automatically pops up)
<label for="tel">Enter a telephone number:</label>
<input type="tel" id="tel"
        placeholder="(555) 555-5555"
        pattern="^(?\d{3})?[-\s]\d{3}[-\s]\d{4}.*?\)"/>

Input type: "url" (for smartphones and tablets, a keyboard layout automatically pops up)
<input type="url1" id="url"/>
 <p>
<label for="url2">Enter a URL (custom validation, must start with http, https or ftp):</label>
    <input id="url2" type="url" placeholder="http://www.domain.com"
           pattern="(http|https|ftp)\:\/\/[a-zA-Z0-9\-\.\/]*"/><p>

Example simple validation using CSS:
<form>
  <label for="url_input">Enter a URL:</label>
  <input type="url" id="url_input" />
  <br />
  <br />
  <label for="email_input">Enter an email address:</label>
  <input type="email" id="email_input" required/>
</form>

input:invalid {
  background-color: #ffdddd;
}

form:invalid {
  border: 5px solid #ffdddd;
}

input:valid {
  background-color: #ddffdd;
}

form:valid {
  border: 5px solid #ddffdd;
}
  
input:required {  /* equivalent to using #email_input:required */
  border-color: #800000;
  border-width: 3px;
}

input:required:invalid {
  border-color: #C00000;
}

Number input type:
<input type="number">
Good for entering integers and floats but not zipcodes which should use text type with a pattern matching possible hyphen

Range input type:
<script>
      window.onload = function() {
        printValue('slider1','rangeValue1');
      }
      function printValue(sliderId, outputId) {
      var x = document.getElementById(outputId);
      var y = document.getElementById(sliderId);
      x.value = y.value;
      }
</script>
  </head>
  <body>
    <form >
      <label for="slider1">Select a value:</label>
      <input id="slider1" type="range"
        min="100" max="500" step="10" value="150"
        oninput="printValue('slider1','rangeValue1')"/>
      <output id="rangeValue1"></output>
    </form>
    <br/>
      Play with attributes: value, min, max, step...
  </body>

HTML5 Attributes
form
readonly
autocomplete
autofocus
list
pattern
required*
placeholder
multiple
list
min
max
step
formaction
formenctype
formmethod
formtarget
formnovalidate

<!-- Form -->
Useful for putting input fields outside the form itself.  Good in conjunction with <fieldset> for page/form layout.
  <body>
    <label for="yourName">Enter your name:</label>
    <input type="text" id="yourName" name="yourName" form="form1"/>   <!-- This textbox will be outside the fieldset box -->
    <p>
    <form id="form1" action="sumit.php" method="post">
      <fieldset>
        <legend>Choose option</legend>
        <label for="free">Free registering</label>
        <input type="checkbox" id="free"/>
        <label for="premium">Premium</label>
        <input type="checkbox" id="premium"/>
        <button type="submit">Send form</button>
      </fieldset>
    </form>
  </body>

<!-- Autofocus -->
Default focus is given to first input field of page.  To specify another input field's focus on page load,
use autofocus attr.  No more than one input element should have this attr.

<!-- List with datalist -->
Enables autocomplete with dropdown of matching options.
<form>
    ...
    <input list="browsers" id="mybrowser" />
    <datalist id="browsers">
       <option value="Internet Explorer">
       <option value="Firefox">
       <option value="Chrome">
       <option value="Opera">
       <option value="Safari">
    </datalist>
...
</form>

<!-- Pattern -->
The pattern attribute enables the validation of the user's input on the fly (also at submission time), 
based on regular expressions. It applies to the text, search, url, tel, email, and password input types. 
Ready-to-go patterns at http://html5pattern.com/
Regex tester: https://regex101.com/#javascript

<!-- Multiple -->
The multiple attribute is used with email and file input types
Used for entering multiple comma-separated emails or selecting multiple files.

<!-- Form elements -->
<datalist>
<output>
<meter>
<progress>

<!-- Output -->
As input field values are considered as strings by JavaScript, using x.value = a.value + b.value 
would result in a string concatenation instead of an addition. That's why we use the valueAsNumber property.
HTML5 has introduced new input field properties: valueAsNumber and valueAsDate. 
The last example is similar to the previous one except that we use an addition instead of a multiplication.

As input field values are considered as strings by JavaScript, using x.value = a.value + b.value would 
result in a string concatenation instead of an addition. That's why we use the valueAsNumber property.
<body>
  Example 1 :<p>
<form oninput="o.value=a.value*b.value">
  <input type="number" name="a" value="2"> x
  <input type="number" name="b" value="3"> =
  <output for="a b"    name="o">6</output>
</form>
  
  Example 2 :<p>
<form oninput="x.value=a.valueAsNumber+b.valueAsNumber">
  <input type="range" name="a" value="50" /> 100+
  <input type="number" name="b" value="50" /> = 
  <output for="a b" name="x"></output>
</form>

<!-- Meter -->
Display colored gauge bar to correspond to range widget
<body>
<pre>&lt;meter value=75 min=0 low=20 high=80 max=100 optimum=19 &gt;&lt;/meter&gt;</pre>

<p>Grades: <meter id="meter2" value="75"  min=0 low=20  high=80 max=100 optimum=19>75%</meter> 
  
<input min="0" max="100"   value="75" id="meter2range" oninput="effect('meter2', 'meter2range')" type="range"> 
  <output id="meter2val" for="meter2range"></output></p>
 <script>
 function effect(meter, meterrange) {
	var currVal = document.getElementById(meterrange).value;
	document.getElementById(meter).value =  currVal;
	document.getElementById(meter+ "val").innerHTML = currVal;
 }
 </script>
</body>

<!-- Progress -->
Download progress:  <progress id=pr value=500  max=1000></progress> 
  <script>
    var i=500;
			window.setInterval(function () {
			  i = (i+1) %1000;
			  document.getElementById('pr').value = i;
			},1);
  </script>
</body>

More on realtime data validation using CSS3
Use 'title' attr to customize dialogue box msg associated with invalid data input.

      input:invalid { background-color: lightPink;}
      input:valid { background-color:lightGreen; }
      input:required {border: 2px solid red;}
      input:optional {border: 2px solid green;}

Example using icon inside input field to indicate validity of data.
<!DOCTYPE html>
<html>
  <head>
    <title>CSS3 pseudo-classes for form validation visual feedback</title>
<style>
.myForm input:required:valid { background:url('http://i.imgur.com/BJolppS.png') no-repeat right top;
}
.myForm input:required {
  background:url('http://i.imgur.com/7pIN7wz.png') no-repeat right top;
}
</style>
  </head>
<body>

<form class="myForm">
  <fieldset>
    <legend>Type invalid values and see the result</legend>
  <label for="myEmail" class="formLabel">E-mail:</label> <input type="email" id="myEmail" required/><br>
    <button>Submit form</button><br />
  </fieldset>
</form>

</body>
</html>

Ensuring 2nd password matchest first, and using setCustomValidity() to customize dialog msg for invalid input.
An empty string msg indicates valid data.
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Example of using the validation API</title>
    <style>
      .myForm input:invalid { background-color: lightPink;}
      .myForm input:valid { background-color:lightGreen; }
      .myForm input:required {border: 2px solid red;}
      .myForm input:optional {border: 2px solid green;}
      .myForm label { display: inline-block; width: 140px; text-align: right; } 
    </style>
  </head>

  <body>
    <form class="myForm">
      <fieldset>
        <legend>Example use of the validation API</legend>
          <label for="password1" >Password:</label> <input type="password" id="password1" oninput="checkPasswords()" required>
          <p>
          <label for="password2">Repeat password:</label> <input type="password" id="password2" oninput="checkPasswords()" required>
          <p>
       <button>Submit</button>
      </fieldset>
    </form>
    
    <script> 
     function checkPasswords() {
       var password1 = document.getElementById('password1');
       var password2 = document.getElementById('password2');
       if (password1.value != password2.value) {
         password2.setCustomValidity('Passwords non identiques');
       } else {
         password2.setCustomValidity('');
       }
     }
    </script>
  </body>
</html>

<!-- Fine tuning validation messages using validity property of input elements -->
<!-- can also access the messages using 
console.log("Validation message = " + input.validationMessage);
-->
<body>  
  <script>
    function validate() {
      var input = document.getElementById('b');
      var validityState_object = input.validity;
      
      if(validityState_object.valueMissing) {
         input.setCustomValidity('Please set an age (required)');	
      } else if (validityState_object.rangeUnderflow) {
         input.setCustomValidity('Your value is too low');
      } else if (validityState_object.rangeOverflow) {
         input.setCustomValidity('Your value is too high');
      } else if (validityState_object.typeMismatch) {
         input.setCustomValidity('Type mismatch');
      } else if (validityState_object.tooLong) {
         input.setCustomValidity('Too long');
      } else if (validityState_object.stepMismatch) {
         input.setCustomValidity('stepMismatch');
      } else if (validityState_object.patternMismatch) {
         input.setCustomValidity('patternMismatch');
      } else {
        input.setCustomValidity('');
      }
    }
  </script>
  <form>
      <label for="b">Enter a value between 10 and 20 </label> 

      <input  type="number" name="text" id="b"
              required  min="10" max ="20" step="1" oninput='validate()'/>    
        <input type="submit"/>
  </form>
  
</body>

<!-- Custom validation: changing the default behavior, aggregating error messages, removing bubbles, etc. -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Aggregating error messages</title>
        <style>
            input:invalid { background-color: lightPink;}
            input:valid { background-color:lightGreen; }
            input:required {border: 2px solid red;}
            input:optional {border: 2px solid green;}

            .error-messages {
                display: none;
                margin: 0 10px 15px 10px;
                padding: 8px 35px 8px 30px;
                color: #B94A48;
                background-color: #F2DEDE;
                border: 2px solid #EED3D7;
                border-radius: 4px;
            }
            fieldset {
                border:1px solid;
                padding:20px;
            }
           label { display: inline-block; width: 140px; text-align: right; } 
        </style>
    </head>
    <body>
        <form>
            <fieldset>
              <legend>Submit with one or two invalid fields </legend>
                <ul class="error-messages"></ul>
                <label for="name">Name:</label>
                <input id="name" name="name" required>
                <p>
                    <label for="email">Email:</label>
                    <input id="email" name="email" type="email" required>
                <p>
                    <button>Submit</button>
            </fieldset>

        </form>

        <script>
            function replaceValidationUI(form) {
                // Suppress the default bubbles
                form.addEventListener("invalid", function (event) {
                    event.preventDefault();
                }, true);

                // Support Safari, iOS Safari, and the Android browser—each of which do not prevent
                // form submissions by default
                form.addEventListener("submit", function (event) {
                    if (!this.checkValidity()) {
                        event.preventDefault();
                    }
                });

                // Container that holds error messages. By default it has a CSS display:none property
                var errorMessages = form.querySelector(".error-messages");

                var submitButton = form.querySelector("button:not([type=button]), input[type=submit]");

                submitButton.addEventListener("click", function (event) {
                    var invalidFields = form.querySelectorAll("input:invalid"),
                            listHtml = "",
                            errorMessagesContainer = form.querySelector(".error-messages"),
                            label;

                    // Get the labels' values of their name attributes + the validation error
                    // message of the corresponding input field using the validationMessage
                    // property of input fields
                    // We build a list of <li>...</li> that we add to the error message container
                    for (var i = 0; i < invalidFields.length; i++) {
                        label = form.querySelector("label[for=" + invalidFields[ i ].id + "]");
                        listHtml += "<li>" +
                                label.innerHTML +
                                " " +
                                invalidFields[ i ].validationMessage +
                                "</li>";
                    }

                    // Update the list with the new error messages
                    errorMessagesContainer.innerHTML = listHtml;

                    // If there are errors, give focus to the first invalid field and show
                    // the error messages container by setting its CSS property display=block
                    if (invalidFields.length > 0) {
                        invalidFields[ 0 ].focus();
                        errorMessagesContainer.style.display = "block";
                    }
                });
            }

            // Replace the validation UI for all forms
            var forms = document.querySelectorAll("form");
          
            for (var i = 0; i < forms.length; i++) {
                replaceValidationUI(forms[ i ]);
            }
        </script>
    </body>
</html>


<!------ HTML5 JavaScript APIs ------>

<!-- HTML5 cache / offline applications -->
Caching is not a new feature of HTML, but with HTML5 there is more control of what or what not to cache
at the application layer.
Specify cache file inside of which lists all files that need to be cached, including images, libraries like jquery, etc.
<html manifest="myCache.appcache">
...
</html>
Any html page with manifest will be cached by default.
Example manifest file(must have CACHE MANIFEST first line):
CACHE MANIFEST
clock.html
clock.css
clock.js

The HTTP server that serves your files must be configured so that .appcache files are served with the
MIME type text/cache-manifest. For example, with the Apache server, this line must be added in the 
HTTP.conf configuration file (or in the .htaccess files): 
AddType text/cache-manifest .appcache

PITFALL #1: When a file is available in the cache and on the remote HTTP server, it will always be retrieved from the cache!
PITFALL #2: If one file cannot be retrieved and cached, none of the files will be updated in the cache.

Another manifest file example:
The CACHE section specifies the URLs of the resources that must be cached
The NETWORK section is the contrary of the CACHE section: it is useful for specifying resources that should NOT be cached.
The FALLBACK section specifies resources that will be displayed when the user requests a resource that is not available when offline. 

CACHE MANIFEST
CACHE:
#images      # for comment
/images/image1.png
/images/image2.png
#pages
/pages/page1.html
/pages/page2.html
#CSS
/style/style.css
#scripts
/js/script.js
FALLBACK:
/ /offline.html
NETWORK:
login.html

Tools for generating manifest files:
1. ManifestR: a manifest file generator (http://westciv.com/tools/manifestR/)
manifestR is a bookmarklet, meaning that you are able to drag it to your bookmarks bar. Then, when you visit 
a page, you will click on the manifestR button, and it will create an HTML5 appcache manifest file for that page.

2. Confess.js: multi purpose command line tools
Confess.js is a small script library that uses PhantomJS 1.2 (or later) to analyze Web pages. Currently it can perform the following tasks:

Generation of an appcache manifest for a Web app
Simple performance analysis of a Web page and its resources
List of CSS properties used on the page

3. Cache validators
Manifesto is an HTML5 Offline Application Cache verification bookmarklet.

When a resource is in the cache, it will ALWAYS be retrieved from the cache, even if you are online, and even if a more recent version is available on your Web server.
To force an update, best practice is to update the manifest file server side.  Modifying the manifest file triggers browser to check if all files under CACHE section needs updating.

Clearing cache for debugging in Chrome: dev tools - application tab, clear storage

Cache size is limited, but generally sufficient.  Browser also knows to extend size if when needed.

To check status of browser, use navigator.online
Note this only checks for local network connectivity and doesn't guarantee the remote server is up or that the DNS server is operational.




<!-- Web storage API: localStorage, sessionStorage -->
Both are key-value stores, but localStorage remains until deleted and sessionStorage values are deleted when tab/browser is closed.
Advantages over cookies:
The main difference is in size limits: cookies are limited to a few KBytes whereas Web Storage may extend to several MBytes. Also cookies generate additional HTTP request traffic (whether to request a Web page, an image, a stylesheet, a JavaScript file, etc.).
Objects managed by Web Storage are no longer carried on the network and HTTP, and are easily accessible (read, change and delete) from JavaScript, using the Web Storage API.
Downside to cookies: if a user has two tabs open to the same site, they will share the same cookies. Which is to say that if you are storing information about a given operation using cookies in one tab, that information will leak to the other side — this can be confusing if the user is performing different tasks in each.
By using sessionStorage, the data you store will be scoped and therefore not leak across tabs!
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
  <script>
    // Using localStorage
    // store data
    localStorage.lastName = "Bunny";
    localStorage.firstName = "Bugs";
    localStorage.location = "Earth";
    
    // retrieve data
    var lastName = localStorage.lastName;
    var firstName = localStorage.firstName;
    var location = localStorage.location;
    
    console.log("lastName just retrieved from the localStorage of your browser, for this particular web site: " + lastName);
    </script>
</head>
<body>

</body>
</html>

Example 1: save form's content as you type (see better version further below)
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Form example</title>
</head>
<body>
<form action="myServerComponent.php" method="POST">
  <fieldset>
    <legend>Personal informations</legend>
    
    <label for="firstName">First name:</label>
    <input type="text" id="firstName" required name="firstName"
           oninput="localStorage.firstName=this.value;">
    
    <br>
    
    <label for="lastName">Last name:</label>
    <input type="text" id="lastName" required name="lastName"
           oninput="localStorage.lastName=this.value;">
    
    <br>
     <label for="email">Email:</label>
    <input type="email" id="email" required name="email"
           oninput="localStorage.email=this.value;">
    
     <br>
     <label for="age">Age:</label>
    <input type="number" min=0 max=120  step=5 id="age" 
           required name="age"
           oninput="localStorage.age=this.value;">
 
         <br>
     <label for="date">Birth date:</label>
    <input type="date"  id="date" required name="date"
           oninput="localStorage.date=this.value;">
  </fieldset>
  
  <button>Submit form</button>
  </form>
</body>
</html>


function restoreFormContent() {
  console.log("restoring form content from localStorage");
  
  if(localStorage.firstName !== undefined) 
    document.getElementById("firstName").value = localStorage.firstName;
 
  if(localStorage.lastName !== undefined) 
    document.getElementById("lastName").value = localStorage.lastName;
  
  if(localStorage.email !== undefined) 
    document.getElementById("email").value = localStorage.email;

  if(localStorage.age !== undefined) 
    document.getElementById("age").value = localStorage.age;
  
  if(localStorage.date !== undefined) 
    document.getElementById("date").value = localStorage.date;

}

// Called when the page is loaded
window.onload = restoreFormContent;

Other methods:
localStorage.setItem(...),
localStorage.getItem(...),
localStorage.removeItem(...),
localStorage.clear().

Example using those methods:
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset=utf-8 />
<title>Example of localStorare API use</title>
  <script>
    // Using localStorage
 
    var counter = localStorage.getItem("count") || 0;
    counter++;
    localStorage.setItem("count", counter);
 
    function getCountValue() {
       // retrieve data
       document.querySelector("#counter").innerHTML = localStorage.count;
    }
    
    function seeAllKeyValuePairsStored() {
      // clear list first
      document.querySelector('#list').innerHTML="";
      
      for (var i = 0, n = localStorage.length; i < n; i++) {
        var key = localStorage.key(i);
        var value = localStorage[key];
        console.log(key + ": " + value);
        
        var li = document.createElement('li');
          li.innerHTML = key + ": " + value;
          document.querySelector('#list').insertBefore(li, null);
      }
    }     
    
    function resetStore() { 
      // erase all key values from store 
      localStorage.clear();
      // reset displayed list too
      document.querySelector('#list').innerHTML="";
    }
    function addSomeData() {
      // store data
      localStorage.lastName = "Buffa";
      localStorage.firstName = "Michel";
      // refresh display
      seeAllKeyValuePairsStored();
    }
     function removeSomeData() {
      // store data
      localStorage.removeItem("lastName");
       localStorage.removeItem("firstName");
      // refresh display
      seeAllKeyValuePairsStored();
    }
  </script>
</head>
<body onload="getCountValue()">
  <h1>Number of time this page has been seen on this browser: <span id="counter"></span></h1>
 
  <button onclick="seeAllKeyValuePairsStored()">Show all key value pairs stored in localStorage</button><br/>
  <output id="list"></output>

  <button onclick="addSomeData()">Add some data to the store</button><br/>
  <button onclick="removeSomeData()">Remove some data</button><br/>
   <button onclick="resetStore()">reset store (erase all key/value pairs)</button>
</body>
</html>

Save/restore user's preferences
Example:
<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>JS Bin</title>
  <script>
    var canvas, ctx;
    var width, height;
    var x, y;
    // Move 3 pixels left or right at each frame
    var incX = 3;
    var size = 10;
   
    // Called after the DOM is ready (page loaded)
    function init() {
 
      // init the different variables
      canvas = document.querySelector("#mycanvas");
      ctx = canvas.getContext('2d');
      
      width = canvas.width;
      height = canvas.height;
      
      // default values
      x=10; y = 10;
      ctx.fillStyle='red';
           
      // Restore last state
      initPreferences();
      
      // Start animation
      animationLoop();
    }
    
    function animationLoop() {
      // an animation is : 1) clear canvas and 2) draw shapes, 
      // 3) move shapes, 4) recall the loop with requestAnimationFrame
      
      // clear canvas
      ctx.clearRect(0, 0, width, height);
     
      ctx.fillRect(x, y, size, size);
      ctx.strokeRect(x, y, size, size);
     
      // move rectangle
      x += incX;
      
      // check collision on left or right
      if(((x+5) > width) || (x <= 0)) {
        // cancel move + inverse speed
        x -= incX;
        incX = -incX;
      }
      
      // animate again at 60 frames/s
      requestAnimationFrame(animationLoop);
    }  
    
    function changeSpeed(event) {
      incX = Math.sign(incX)*parseInt(event.target.value);
      document.getElementById("speedValue").innerHTML = Math.abs(incX);
      
    }
    function changeColor(event) {
      ctx.fillStyle = event.target.value;
    }
    function changeSize(event) {
      size =parseInt(event.target.value);
      document.getElementById("sizeValue").innerHTML = size;
    }
    function changeLineWidth(event) {
      ctx.lineWidth = parseInt(event.target.value);
    }
  </script>
</head>
  
<body onload="init();">
  <canvas id="mycanvas" width="200" height="50" style="border: 2px solid black"></canvas>
  <p>
   <label for="size">Size of the rectangle:</label> <input type="range" id="size" min=10 max=40 value=10 oninput="changeSize(event);"><output id="sizeValue">10</output><p>
  <p>
 
    <label for="color">Color:</label> <input id="color" type="color" value='#FF0000' oninput="changeColor(event);">
 
    <p>
    <label for="lineWidth">Line width of outline using <code>&lt;input type=number&gt;</code>:</label> <input type="number" id="lineWidth" value=1 min=1 max=5 oninput="changeLineWidth(event);">
    <p>
     <label for="speed">Speed:</label> <input id="speed" type="range" min=1 max=10 value=3 oninput="changeSpeed(event);"><output id="speedValue">3</output><p>
</body>
</html>

Javascript

function initPreferences() {
  console.log("Adding input listener to all input fields");
  // add an input listener to all input fields
  var listOfInputsInForm = document.querySelectorAll("input");
   for(var i= 0; i ((lt)) listOfInputsInForm.length; i++) {
     addInputListener(listOfInputsInForm[i]);
   }
  
  // restore preferences
  restorePreferences();
  
  applyGUIvalues();
}

function addInputListener(inputField) {
  inputField.addEventListener('input', function(event) {
    localStorage.setItem(inputField.id, inputField.value);
  }, false);
}

function restorePreferences() {
  console.log("restoring form content from localStorage");
  
  // get the list of all input elements in the form
  var listOfInputsInForm = document.querySelectorAll("input");
  
  // For each input element, 
  //    - get its id (that is also the key for it is saved content 
  //      in the localStorage)
  //    - get the value associated with the id/key in the local
  //      storage
  //    - If the value is not undefined, restore the value
  //      of the input field
  for(var i= 0; i ((lt)) listOfInputsInForm.length; i++) {
    var fieldToRestore = listOfInputsInForm[i];
    var id = fieldToRestore.id;
    var savedValue = localStorage.getItem(id);
    
    if(savedValue !== undefined) {
      fieldToRestore.value = savedValue;
    }
  }
}

function applyGUIvalues() {
  var sizeWidget = document.getElementById("size");
  size = Math.sign(incX)*parseInt(sizeWidget.value);
  document.getElementById("sizeValue").innerHTML = size;
  
  var colorWidget = document.getElementById("color");
  ctx.fillStyle = colorWidget.value;
  
  var speedWidget = document.getElementById("speed");
  incX = Math.sign(incX)*parseInt(speedWidget.value);
  document.getElementById("speedValue").innerHTML = Math.abs(incX);
  
  var lineWidthWidget = document.getElementById("lineWidth");
  ctx.lineWidth = parseInt(lineWidthWidget.value);
}

Better version of example 1 from above by creating generic functions for saving/restoring, 
and not needing to know explicitly how many input fields there are.
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Form example</title>
</head>
<body>
  <h2>Enter values, then reload the page at any time: the form content is restored automatically.</h2> Reusable functions for saving/restoring input field content are used.<p>
  Check also "localStorage" in the devtools.
  <p>
<form action="myServerComponent.php" method="POST" autocomplete="off">
  <fieldset>
    <legend>Personal informations</legend>
    
    <label for="givenName">Given name:</label>
    <input type="text" id="givenName" required name="givenName">
    
    <br>
    
    <label for="familyName">Last name:</label>
    <input type="text" id="familyName" required name="familyName">
    
    <br>
     <label for="email">Email:</label>
    <input type="email" id="email" required name="email">
    
     <br>
     <label for="age">Age:</label>
    <input type="number" min=0 max=120  step=5 id="age" 
           required name="age">
 
         <br>
     <label for="date">Birth date:</label>
    <input type="date"  id="date" required name="date">
  </fieldset>
  
  <button>Submit form</button>
  </form>
</body>
</html>

function sendForm() {
  console.log("in sendForm()");
  
  // SEND THE FORM USING AJAX
  
  // PERFORM CUSTOM VALIDATION
  
  return false;
}

// Called when the page is loaded
window.onload = init;

function init() {
  console.log("Adding input listener to all input fields");
  // add an input listener to all input fields
  var listOfInputsInForm = document.querySelectorAll("input");
   for(var i= 0; i ((lt)) listOfInputsInForm.length; i++) {
     addInputListener(listOfInputsInForm[i]);
   }
  
  // restore form content with previously saved values
  restoreFormContent();
}

function addInputListener(inputField) {
  inputField.oninput = function(event) {
    localStorage.setItem(inputField.id, inputField.value);
  };
}

function restoreFormContent() {
  console.log("restoring form content from localStorage");
  
  // get the list of all input elements in the form
  var listOfInputsInForm = document.querySelectorAll("input");
  
  // For each input element, 
  //    - get its id (that is also the key for it is saved content 
  //      in the localStorage)
  //    - get the value associated with the id/key in the local
  //      storage
  //    - If the value is not undefined, restore the value
  //      of the input field
  for(var i= 0; i ((lt)) listOfInputsInForm.length; i++) {
    var fieldToRestore = listOfInputsInForm[i];
    var id = fieldToRestore.id;
    var savedValue = localStorage.getItem(id);
    
    if(savedValue !== undefined) {
      fieldToRestore.value = savedValue;
    }
  }
}

Storing JSON objects rather than strings (JSON.stringify() and JSON.parse() methods):
Typical usage:
locaStorage.key = JSON.stringify(object);
localStorage.setItem(key, JSON.stringify(object));

A full-fledged example:
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Servlerless contact manager</title>
</head>
<body>
  
	<header>
		<h1>Servlerless contact manager that uses localStorage and JSON</h1>
	</header>
	<nav>
		<ul>
			<li><a href="index.html">Home</a></li>
			<li>/</li>
			<li>Contacts</li>
		</ul>
	</nav>
  <section>
    <article id="formContacts">
      <header>
        <h2>Add new contact</h2>
      </header>
      <details>
        <summary>
          Click to open the form
        </summary>
			<form onsubmit="return submitForm();">
				<fieldset>
					<legend>New contact</legend>
					<label for="familyname">
						<span>family name:</span>
						<input type="text" name="familyName" id="familyName" maxlength="32" required>
					</label>
					<label for="givenName">
						<span>Given name:</span>
						<input type="text" name="givenName" id="givenName" maxlength="32" required >
					</label>
                  	<label for="tel">
						<span>Phone:</span>

                                      <input type="tel" name="tel" id="tel" required placeholder="123-456-7890" pattern="\d{3}[\-]\d{3}[\-]\d{4}">
					</label>

					<label for="email">
						<span>Email:</span>
						<input type="email" name = "email" id="email" maxlength="128">
					</label>
					<label for="birthDate">
						<span>Birth date:</span>
						<input name="birthDate" id="birthDate" type="date">
					</label>
					<label for="children">
						<span>Number of children:</span>
						0 <input type="range" name = "children" id="children" min="0" max="5" required> 5
					</label>					
				</fieldset>
				<button id="addClient" type="submit">OK</button>
			</form>	
      </details>
    </article>
	<article id="contacts">
		<header>
			<h2>Contact list</h2>
		</header>
			<table>
				<thead>
					<tr>
						<th>Given name</th>
						<th>Family name</th>
                        <th>Phone</th>
						<th>Email</th>
                      	<th>Birth date</th>
						<th>Nb children</th>
					</tr>
				</thead>
				<tbody id="tableContactBody">
				</tbody>
			</table>
			<button id="createContact">New contact</button>
	</article>
    </section>

	<aside id="journalActions">
		<div>Recent actions</div>
      <ul>
        <li>Added Eddy Mitchell</li>
      </ul>
	</aside>
	<footer>W3Cx HTML5 part 1 MOOC</footer>
</body>
</html>

CSS
body {
	position: relative;
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
	font-size: 14px;
	line-height: 20px;
	color: #333333;
	width: 640px;
	margin-bottom: 150px;
}

table {
	border-spacing: 0;
	width: 100%;
	border: 1px solid #dddddd;
	border-collapse: separate;
	border-left: 0;
	-webkit-border-radius: 4px;
	-moz-border-radius: 4px;
	border-radius: 4px;
}

tbody>tr:nth-child(odd)>td {
	background-color: lightGrey;
}

tr {
	border-collapse: separate;
}

th,td {
	padding: 8px;
	line-height: 20px;
	text-align: left;
	vertical-align: top;
	border-left: 1px solid #dddddd;
}

td {
	border-top: 1px solid #dddddd;
}

tbody:last-child tr:last-child>td:first-child {
	-webkit-border-bottom-left-radius: 4px;
	border-bottom-left-radius: 4px;
	-moz-border-radius-bottomleft: 4px;
}

tbody:last-child tr:last-child>td:last-child {
	border-bottom-right-radius: 4px;
}

nav ul {
	padding: 8px 15px;
	margin: 0 0 20px;
	list-style: none;
	background-color: #f5f5f5;
	border-radius: 4px;
}

nav li {
	display: inline-block;
	text-shadow: 0 1px 0 #ffffff;
}

nav li a {
	text-decoration: none;
}

button {
	padding: 4px 12px;
	color: #333333;
	background-image: -moz-linear-gradient(top, #ffffff, #e6e6e6);
	background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ffffff),
		to(#e6e6e6));
	background-image: -webkit-linear-gradient(top, #ffffff, #e6e6e6);
	background-image: -o-linear-gradient(top, #ffffff, #e6e6e6);
	background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);
	border: 1px solid #cccccc;
	border-color: #e6e6e6 #e6e6e6 #bfbfbf;
	border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
	border-bottom-color: #b3b3b3;
	border-radius: 4px;
}

button:active {
	-webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
	color: #333333;
	background-color: #e6e6e6;
}

button:hover, button:focus {
	background-color: #e6e6e6;
	color: #333333;	
}

section button {
	position: absolute;
	right: 0px;
	margin-top: 20px;
}

footer button {
	top: 15px;
	position: absolute;
	right: 10px;
}

aside {
	position: absolute;
	top: 40px;
	left: 660px;
	width: 300px;
	min-height: 20px;
	padding: 19px;
	padding-top: 10px;
	margin-bottom: 20px;
	background-color: #f5f5f5;
	border: 1px solid #e3e3e3;
	border-radius: 4px;
	box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05);
}

footer {
	position: fixed;
	bottom: 0px;
	background-color: lightGrey;
	height: 60px;
	left: 0px;
	text-align: center;
	width: 100%;
	line-height: 60px;
	font-weight: bold;
}


input {
	margin-bottom: 10px;
}

input[type=range] {
	width: 225px;
}
input:invalid {
  background-color:pink;
}

input:valid {
  background-color:lightGreen;
}
label {
	display: block;
}


label > span {
	display: inline-block;
	width: 250px;
	line-height: 35px;
	vertical-align: top;
}

input {
	width: 250px;
	height: 20px;
	padding: 4px 6px;
	font-size: 14px;
	line-height: 20px;
	vertical-align: middle;
	-webkit-border-radius: 4px;
	-moz-border-radius: 4px;
	border-radius: 4px;
}

fieldset {
	-webkit-border-radius: 4px;
	-moz-border-radius: 4px;
	border-radius: 4px;
}

.trash-icon {
	margin-top: 10px;
}

JavaScript
// Different elements from the form in the HTML page
var contactForm, lastNameField, firstNameField, telField, childrenField, emailField, birthDateField;

// Array of contacts to save/load to/from localStorage
var contacts = [];

var textMessageInvalid = "This field contains invalid chjaracters";
var dateMessageInvalid = "Bith date should be in the past";

window.addEventListener("load", function() {
  // called when the page has been entirely loaded
  
  // the form element
  contactForm = document.forms[0]; 
  
  // get the fields elements
  lastNameField = contactForm.familyName;
  firstNameField = contactForm.givenName;
  telField = contactForm.tel;
  emailField = contactForm.email;
  childrenField = contactForm.children;
  birthDateField = contactForm.birthDate;
  
  // read contacts from localStorag
  contacts = getContacts();
  
  // Builds and display the table of contacts
  buildContactTable(contacts);
  

  // Listener for input events on the two text fields. Check for
  // invalid charcters %, &, $, ! that are forbidden.
  lastNameField.oninput = firstNameField.oninput = function() {
	if (this.value.match(/[%&$!]/)) {
		this.setCustomValidity(textMessageInvalid);
	} else {
		this.setCustomValidity("");
	}
};

  // Listener for input events on the date field. Checks that the date is 
  // in the past
birthDateField.oninput = function() {
	if (this.valueAsDate >= new Date()) {
		this.setCustomValidity(dateMessageInvalid);
	} else {
		this.setCustomValidity("");
	}
}; 
  
});

// Called when the form is submitted
function submitForm() {
  // When we execute this function, the form has already been validated
  // by the HTML5 built-in validation system (bubbles etc.)
  console.log("We are saving the current contact in the form");
  
  // Create a new contact JavaScript object with the current values
  // in the form inoput fields
 var contact = {};
  contact.givenName = firstNameField.value;
  contact.familyName = lastNameField.value;
  contact.tel = telField.value;
  contact.email = emailField.value;
  contact.birthDate = birthDateField.value; 
  contact.children = childrenField.value;
  
  // Add the contact in the array of contacts
  contacts.push(contact);
  
  // Save the array of contacts in JSON format
  localStorage.contacts = JSON.stringify(contacts); 
  
  // Update the HTML table with the new contact at the end
  addLineToHTMLTable(contact);
  
  // do not submit the form using HTTP, return false prevents this
  // submission
  return false;
} 
  
function buildContactTable(contacts) {
	var rowIndex, row;
		
	// iterate on the contact array passed as parameter
	for (rowIndex = 0; rowIndex ((lt)) contacts.length; rowIndex++) {		
		// Add a line in the HTML table for the current contact
		addLineToHTMLTable(contacts[rowIndex]);
	}
}

// Add a line to the HTML table, corresponding to the contact
// passed as parameter
function addLineToHTMLTable(contact) {
  	var row, lastNameColumn, firstNameColumn, telColumn, bithDateColumn; 
	var childrenColumn, emailColumn;
  
    var tableBody = document.getElementById("tableContactBody");
	
    // create a table row element and all tds inside for the diffent
    // contact properties
	row = document.createElement("tr");
	firstNameColumn = document.createElement("td");
	lastNameColumn = document.createElement("td");
    telColumn = document.createElement("td");
	bithDateColumn = document.createElement("td");
	emailColumn = document.createElement("td");
	childrenColumn = document.createElement("td");
		
	// fill the tds
	lastNameColumn.innerHTML = contact.familyName;
	firstNameColumn.innerHTML = contact.givenName;
    telColumn.innerHTML = contact.tel;
	bithDateColumn.innerHTML = contact.birthDate;
	emailColumn.innerHTML = contact.email;
	childrenColumn.innerHTML = contact.children;
		
				
	// Adds tds to the row		
	row.appendChild(lastNameColumn);
	row.appendChild(firstNameColumn);
    row.appendChild(telColumn);
	row.appendChild(bithDateColumn);
	row.appendChild(emailColumn);
	row.appendChild(childrenColumn);
  
    // add row to the table body
    tableBody.appendChild(row);
}

// Read contacts from localStorage
function getContacts() {
	var contacts = localStorage.contacts;
	if (contacts) {
		return JSON.parse(contacts);
	} else {
		return [];
	}
}

<!-- Working with local files -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
</head>
<body>
<input type="file" multiple onchange="readImagesAndPreview(this.files);"><p>
  <div id="thumbnails"></div>
  <script>
    var container = document.getElementById("thumbnails");
    
    function readImagesAndPreview(files) {
      for(var i=0; i < files.length; i++) {
         var f = files[i];
      
         var reader = new FileReader();
        
         reader.onload = function(e) {
           var img = document.createElement("img");
           img.src = e.target.result;
           img.width = 100;
           
           container.appendChild(img);
        }
      
        reader.readAsDataURL(f);
      }
    }
    
  </script>
</body>
</html>

<!-- Getting details about a file: reading a file's metadata -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset=utf-8 />
<title>Reading file metadata</title>
  <script>
    function displayFirstSelectedFileMetadata() {
      var selectedFile = document.getElementById('input').files[0];
      document.querySelector("#singleName").innerHTML = selectedFile.name;
      document.querySelector("#singleSize").innerHTML = selectedFile.size + "  bytes";
      document.querySelector("#singleType").innerHTML = selectedFile.type;
      document.querySelector("#singleDate").innerHTML = selectedFile.lastModifiedDate;
    }
  </script>
</head>
<body>
  Select one or more files: <input type="file" id="input" onchange="displayFirstSelectedFileMetadata();"/>
<p>
  <ul>
    <li>File name: <span id="singleName"></span></li>
    <li>File size: <span id="singleSize"></span></li>
    <li>File type: <span id="singleType"></span></li>
    <li>File last modification date: <span id="singleDate"></span></li>
  </ul>
  
</body>
</html>

<!-- the Blob interface helps read binary data (only) that is accessed slice by slice (as chunks of data, each one being a "Blob") -->
Example:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>HTML5 file upload with monitoring</title>
  </head>

  <body>
    <button onclick="startDownload();">Start downloading a flower</button>
    <br/><br />
    <progress value=0 id="progress"></progress>
    <p>
    <div id="container"></div>
    <script>
      var progress = document.getElementById("progress");
       var container = document.getElementById("container");
      
   function startDownload() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', "https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/HTML5_logo_and_wordmark.svg/1000px-HTML5_logo_and_wordmark.svg.png", true);
     xhr.responseType = 'blob';

     xhr.onprogress = function(e) {
       console.log("downloading");
            progress.value = e.loaded;
            progress.max = e.total;
        };
  xhr.onload = function(e) {
    console.log("loaded"); 
    var image = document.createElement("img");
    image.src = window.URL.createObjectURL(this.response);
    
   
    container.appendChild(image);
  };
      xhr.onerror = function(e) {
    console.log("error");                         
  };
  xhr.send();
     console.log("request sent");
}
    </script>
  </body>
</html>

<!-- Reading multiple files as text -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Example of use of FileReader with a text file</title>
</head>
<body>
<label for="files">Choose a text file:</label><input type="file" id="files" multiple onchange="readFilesAndDisplayAsText(this.files);"/><br/>
<p>
<textarea rows=30 cols=50 id="filesContent"></textarea> 
 
<script>
  var filesContent = document.getElementById("filesContent");
  
  function readFilesAndDisplayAsText(files) {
    console.log("dans read files");
    // Loop through the FileList and render image files as thumbnails.
    for (var i = 0, f; f = files[i]; i++) {
 
      var reader = new FileReader();      
 
      // Add an onload listener to the reader
      addOnLoadListener(reader, f.name);
      // start reading, will call the listener later, when the file f is read
      reader.readAsText(f);
      
    }
  }
 
  function addOnLoadListener(reader, name) {
    // Add an onload listener that will be able to print the name of the
    // file...
    reader.onload = function(e) {  
        filesContent.value += "###### READING FILE " + name + " ######";
        filesContent.value += e.target.result;
      };
  }
</script>
</body>
</html>

<!-- Reading file content as data URL -->
A data URL is a URL that includes type and content at the same time. It is useful, for example,  for inlining images or videos in the HTML of a Web page (on mobile devices, this may speed up the loading of the page by reducing the number of HTTP requests).
This dataURL format enables file content to be stored in a base64 format (as a string), and adds the MIME type specification of the content. The dataURL can therefore store a file as a URL readable with modern browsers. It is becoming more commonly used on the Web, especially for mobile applications, as inlining images reduces the number of HTTP requests and makes the Web page load faster.

Example 1: read images as data URL and display previews in the page
Example 1 is useful for forms that allow the user to select one or more pictures. Before sending the form, you might want to get a preview of the pictures in the HTML page. The reader.readAsDataUrl method is used for that.
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Example of use of readAsDataURL with images</title>
  <style>
  .thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }
</style>
</head>
<body>
  <label for="files">Choose multiple files:</label>
  <input type="file" id="files" multiple 
         onchange="readFilesAndDisplayPreview(this.files);"/><br/>
  <p>Preview of selected images:</p>
<output id="list"></output>

<script>
  function readFilesAndDisplayPreview(files) {
    // Loop through the FileList and render image files as thumbnails.
    for (var i = 0, f; f = files[i]; i++) {

      // Only process image files.
      if (!f.type.match('image.*')) {
        continue;
      }

      var reader = new FileReader();

      //capture the file information.
      reader.onload = function(e) {
          // Render thumbnail. e.target.result = the image content 
          // as a data URL
        
          // create the span with CSS class="thumb", for nicer layout
          var span = document.createElement('span');
          // Add an <img src=...> in the span, with src= the dataURL of
          // the image
          span.innerHTML = "<img class='thumb' src='" + e.target.result + "' alt='a picture'/>";
          // Insert the span in the output id=list
          document.getElementById('list').insertBefore(span, null);
        };
      
      // Read in the image file as a data URL.
      reader.readAsDataURL(f);
    }
  }
</script>
</body>
</html>

<!-- Geolocation -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Basic example of use of the geolocation API</title>
  </head>
<body>
<p id="msg">Click the button to get your coordinates:</p>
<button onclick="getLocation()">Where am I ?</button>
  
<script>
var displayCoords=document.getElementById("msg");
  
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showPosition);
  } else {
    displayCoords.innerHTML="Geolocation API not supported by your browser.";
  }
}
  
  
function showPosition(position) {
 displayCoords.innerHTML="Latitude: " + position.coords.latitude + 
  "<br />Longitude: " + position.coords.longitude;	
}
</script>
</body>
</html>

Example that includes checking for errors:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Basic example of use of the geolocation API</title>
  </head>
<body>
<p id="msg">Click the button to get your coordinates:</p>
<button onclick="getLocation()">Where am I ?</button>
  
<script>
var displayCoords=document.getElementById("msg");
  
function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showPosition, errorPosition);
  } else {
    displayCoords.innerHTML="Geolocation API not supported by your browser.";
  }
}
  
  
function showPosition(position) {
 displayCoords.innerHTML="Latitude: " + position.coords.latitude + 
  "<br />Longitude: " + position.coords.longitude;	
}
  
  function errorPosition(error) { 
   var info = "Error during geolocation: ";
 
   switch(error.code) {
     case error.TIMEOUT:
       info += "Timeout !";
       break;
     case error.PERMISSION_DENIED: 
       info += "Permission denied, geolocation could not be obtained...";
       break;
     case error.POSITION_UNAVAILABLE:
       info += "Location could not be obtained though the avaible means...";
       break;
     case error.UNKNOWN_ERROR:
       info += "Unknown error";
       break;
     }
   displayCoords.innerHTML = info;
 }
</script>
</body>
</html>

<!-- Tracking in realtime -->
Tracking a position in real time
Introduction
In order to track the current position, the geolocation API provides a method similar to the getCurrentPosition(onSuccess, onError) named watchPosition(onSuccess, onError). 

When getCurrentPosition gives a position when called, watchPosition does the following:

It gets the callback function only when the current position changes. If you stay in the same location, the callback function won't be called regularly. 
It returns an id so that you can use the clearWatch(id) method to stop the current tracking.
Typical use
// get an id of the current tracking, the showPosition callback is like the one we saw in earlier examples.
var watchPosId = navigator.geolocation.watchPosition(showPosition);
...
// stop the tracking
navigator.geolocation.clearWatch(watchPosId);

Example 1 (easy):  how to get a static image map centered on your longitude and latitude
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Basic example of use of the geolocation API</title>
  </head>
<body>
<p id="demo">Click the button to get your position:</p>
<button onclick="getLocation()">Try It</button>
<div id="mapholder"></div>
  
<script>
var x=document.getElementById("demo");
function getLocation()
  {
  if (navigator.geolocation)
    {
    navigator.geolocation.getCurrentPosition(showPosition,showError);
    }
  else{x.innerHTML="Geolocation is not supported by this browser.";}
  }

function showPosition(position)
  {
  var latlon=position.coords.latitude+","+position.coords.longitude;

  var img_url="https://maps.googleapis.com/maps/api/staticmap?center="
  +latlon+"&zoom=14&size=400x300&sensor=false";
  document.getElementById("mapholder").innerHTML="<img src='"+img_url+"' />";
  }

function showError(error)
  {
  switch(error.code) 
    {
    case error.PERMISSION_DENIED:
      x.innerHTML="User denied the request for Geolocation."
      break;
    case error.POSITION_UNAVAILABLE:
      x.innerHTML="Location information is unavailable."
      break;
    case error.TIMEOUT:
      x.innerHTML="The request to get user location timed out."
      break;
    case error.UNKNOWN_ERROR:
      x.innerHTML="An unknown error occurred."
      break;
    }
  }
</script>
  
</body>
</html>

Example 2 (a bit more complicated...) that shows how to display an interactive Google map centered on the current position
<!doctype html>
<html>
<head>
</head>
<body>
<!-- for position display -->
<div id="myposition"></div>

<!-- for gmap display -->
<div id="map" style="width:640px;height:480px"></div>

<!-- get gmap API -->
<script src="https://maps.google.com/maps/api/js?sensor=false"></script>

<script>
// Default position
var centerpos = new google.maps.LatLng(48.579400,7.7519);

// default options for the google map
var optionsGmaps = {
	center:centerpos,
	navigationControlOptions: {style: google.maps.NavigationControlStyle.SMALL},
	mapTypeId: google.maps.MapTypeId.ROADMAP,
	zoom: 15
};

// Init map object
var map = new google.maps.Map(document.getElementById("map"), optionsGmaps);

if(navigator.geolocation) {

	// callback function, called by getCurrentPosition() in case of success
	function drawPosition(position) {
	
		var infopos = "Got position : <br>";
		infopos += "Latitude : "+position.coords.latitude +"<br>";
		infopos += "Longitude: "+position.coords.longitude+"<br>";
		infopos += "Altitude : "+position.coords.altitude +"<br>";
		document.getElementById("myposition").innerHTML = infopos;

		// Make new object LatLng for Google Maps
		var latlng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);

		// Add a marker at position
		var marker = new google.maps.Marker({
			position: latlng,
			map: map,
			title:"You are here"
		});
		
      // center map on longitude and latitude
		map.panTo(latlng);
	}

	// callback function, called by getCurrentPosition() in case of error
	function errorPosition(error) {
		var info = "Error during geolocation : ";
		switch(error.code) {
		case error.TIMEOUT:
			info += "Timeout !";
		break;
		case error.PERMISSION_DENIED:
			info += "You did not access to the geolocation API";
		break;
		case error.POSITION_UNAVAILABLE:
			info += "Position could not be determined";
		break;
		case error.UNKNOWN_ERROR:
			info += "Unknown error";
		break;
		}
		document.getElementById("myposition").innerHTML = info;
	}
	   navigator.geolocation.getCurrentPosition(drawPosition,errorPosition);
} else {
	alert("Geolocation API not supported by your browser");
}

</script>
</body>
</html>

Example 3
<!DOCTYPE html>
<html lang="en">
  <head> 
      <meta charset="utf-8">
    <title>Basic example of use of the geolocation API</title>
      <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>    
    <script>
       // p elements for displaying lat / long and address
       var displayCoords, myAddress; 
      
      // used with the google apis
      var geocoder;
      var map;
      var infowindow = new google.maps.InfoWindow();
      var marker;
      
      // Called when the page is loaded
      function init() {
        displayCoords=document.getElementById("msg");
        myAddress = document.getElementById("address");
        
        geocoder = new google.maps.Geocoder();
        
        // In order to show something even before a user clicked on the button
        var latlng = new google.maps.LatLng(34.0144, -6.83);
        
        var mapOptions = {
          zoom: 8,
          center: latlng,
          mapTypeId: 'roadmap'
        }
        map = new google.maps.Map(document.getElementById('map_canvas'), mapOptions); 
      }
      
       // Called when the button is clicked
       function getLocation() {
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(showPosition);
          } else {
          displayCoords.innerHTML="Geolocation API not supported by your browser.";
       }
     }
  
    // Called when a position is available
    function showPosition(position) {
        displayCoords.innerHTML="Latitude: " + position.coords.latitude + 
            "<br />Longitude: " + position.coords.longitude;   
      
        // Display the map
        showOnGoogleMap(new google.maps.LatLng(position.coords.latitude, position.coords.longitude));
 
    }
 
 
    function showOnGoogleMap(latlng) {
        // Ask google geocoder for a surface address once we get a longitude and 
        // a latitude. In fact the reverse geocoder sends back an array of "guesses"
        // i.e. not only one address object, but several. Each entry in this array
        // has several properties like street, city, etc. We use the "formatted_address"
        // one here, but it might be interesting to get the detailed properties in other
        // applications like a form with street, city, zip code etc.
        geocoder.geocode({'latLng': latlng},reverseGeocoderSuccess);
      
        function reverseGeocoderSuccess(results, status) {
          if (status == google.maps.GeocoderStatus.OK) {
            // For debugging
            console.dir(results);
            
            if (results[1]) {
              map.setZoom(11);
              marker = new google.maps.Marker({
                  position: latlng,
                  map: map
              });
              infowindow.setContent(results[1].formatted_address);
              infowindow.open(map, marker);
              
              // Display address as text in the page
              myAddress.innerHTML="Adress: " + results[0].formatted_address;

            } else {
              alert('No results found');
            }
          } else {
            alert('Geocoder failed due to: ' + status);
          }
        } // end of reverseGeocoderSuccess
      }  // end of showOnGoogleMap
    </script>
  </head>
  <body onload="init()">
     <title>HTML5 + Geolocalisation + Google Maps API Reverse Geocoding</title>
    
    <p id="msg">Click the button to get your coordinates:</p>
    <p id="address"></p>
 
    <button onclick="getLocation()">Where am I ?</button>
      <div id="map_canvas" style="width: 500px; height: 300px"></div>
  </body>
</html>

Practical example: fill a form's address fields automatically (as suggestions)
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="utf-8">
   <title>Example of geolocation withy auto-fill</title>
   <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
  
    <!--MB code for reverse geolocation-->
    <script>
       var displayCoords, myAddress; 
  
       function getLocation() {
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(showPosition);
          } else {
          displayCoords.innerHTML="Geolocation API not supported by your browser.";
       }
     }
  
  
      // Called when position is available
    function showPosition(position) {
        displayCoords.innerHTML="Latitude: " + position.coords.latitude + 
            "<br />Longitude: " + position.coords.longitude;    
        showOnGoogleMap(new google.maps.LatLng(position.coords.latitude, position.coords.longitude));
 
    }
 
      var geocoder;
      var map;
      var infowindow = new google.maps.InfoWindow();
      var marker;
      
      function initialize() {
        displayCoords=document.getElementById("msg");
        myAddress = document.getElementById("address");
        
        geocoder = new google.maps.Geocoder();
        var latlng = new google.maps.LatLng(34.0144, -6.83);
        var mapOptions = {
          zoom: 8,
          center: latlng,
          mapTypeId: 'roadmap'
        }
        map = new google.maps.Map(document.getElementById('map_canvas'), mapOptions); 
      }
 
    function showOnGoogleMap(latlng) {
 
        geocoder.geocode({'latLng': latlng}, function(results, status) {
          if (status == google.maps.GeocoderStatus.OK) {
            if (results[1]) {
              map.setZoom(11);
              marker = new google.maps.Marker({
                  position: latlng,
                  map: map
              });
              infowindow.setContent(results[1].formatted_address);
              infowindow.open(map, marker);
              
              // Display address as text in the page
              myAddress.innerHTML="Adress: " + results[0].formatted_address;
              
              // Call the function that parses the results and fills
              // the input fields
              parseResult(results[0].address_components);
            } else {
              alert('No results found');
            }
          } else {
            alert('Geocoder failed due to: ' + status); 
          }
        });
    }     
      
      var country, postalCode, state, route, streetNumber, locality, areaLvl1, areaLvl2;
      
      function parseResult(result) {
        for(i in result){
          // Let's print all the data we can collect from the reverse geocoder,
          // Look at the debug console to see what we get...
          console.log("type = " + result[i].types[0] + " long_name = " + 
                       result[i].long_name);

          if(result[i].types[0] == 'postal_code')
            postalCode = result[i].long_name;
          if(result[i].types[0] == 'country')
            country= result[i].long_name;
          if(result[i].types[0] == 'street_number')
           
            streetNumber= result[i].long_name;
          if(result[i].types[0] == 'route')
            route= result[i].long_name;
           if(result[i].types[0] == 'locality')
            locality= result[i].long_name;
          if(result[i].types[0] == 'state')
            state= result[i].long_name;
          if(result[i].types[0] == 'administrative_area_level_2')
            arealLvl2= result[i].long_name;
          if(result[i].types[0] == 'administrative_area_level_1')
            areaLvl1= result[i].long_name;
        }
        // MICHEL BUFFA : added this for debugging in the console
        console.log("postalCode = " + postalCode);
        console.log("country = " + country);
        console.log("streetNumber = " + streetNumber);
        console.log("route = " + route);
        console.log("locality = " + locality);
        console.log("Administrative area level 1 " + areaLvl1);
        console.log("Administrative area level 2 " + areaLvl2);
        
        // fill input fields now, check if variables are undefined
        if((route != undefined) && (streetNumber != undefined)) {
          console.log("let's fill the street");
          document.querySelector("#address1").value = streetNumber + " " + route;
        }
         if(locality != undefined) {
          console.log("let's fill the city");
          document.querySelector("#address2").value =  locality;
        }
        if(country != undefined) {
          console.log("let's fill the country");
          document.querySelector("#country").value =  country;
        } 
        if(postalCode != undefined) {
          console.log("let's fill the postalCode");
          document.querySelector("#postcode").value =  postalCode;
        } 
        if(areaLvl1 != undefined) {
          console.log("let's fill the State/Region");
          document.querySelector("#address3").value =  areaLvl1;
        } 
      }
    </script>
</head>
<body onload="initialize()">
  <h1>Example of the use of Google reverse geocoder + try to fill some address input fields. Original code by John Hollamby.</h1>
 <form>
  
<fieldset>
  <legend>Locate me</legend>
<p id="msg">Click the button to get your coordinates:</p>
    <p id="address"></p>
 
    <button type="button" onclick="getLocation()">Where am I ?</button>
      <div id="map_canvas" style="width: 500px; height: 300px"></div>
</fieldset>
   <fieldset>
   <legend>Address</legend>
   <ol>		   			
    <li>
     <label for="address1">Street Address *</label>
     <input id="address1" name="street_address" type="text" required />
    </li>
	<li>
      <label for="address2">Suburb *</label>
     <input id="address2" name="suburb" type="text" required />
    </li>
	<li>
      <label for="address3">State *</label>
     <input id="address3" name="state" type="text" required />
    </li>		   
    <li>
     <label for="postcode">Postcode *</label>
     <input id="postcode" name="postcode" type="number" min="1001" max="999999" required />
     <p class="validation01">
      <span class="invalid">Your postcode is out of range between 1001 - 999999</span>
       <span class="valid">Your postcode is in the correct range</span>
     </p> 
    </li>
    <li>
     <label for="country">Country *</label>
     <input id="country" name="country" type="text" required />
    </li>
   </ol>
  </fieldset>

 </form>
</body>
</html>
