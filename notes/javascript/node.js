Introduction to Node.js (pluralsight)

////////////////////////////
Module 1
Getting started with Node.js

Can manage multiple version with "nvm" (https://github.com/creationix/nvm)
Good for updating to new release and for testing code between different node versions.
git clone git://github.com/creationix/nvm.git ~/nvm
. ~nvm/nvm.sh
nvm install 0.8.14
nvm use 0.6.19		// use a different version (if installed)
nvm alias default 0.8.14

Node.js built on:
1. libuv	- A high performance, cross-platform evented I/O library
2. v8 		- JavaScript engine from Google (also used in Chrome)
3. js, c++	- Code developed for the node platform.

Cloud9 IDE
https://c9.io

Node Event Loop
Much like event loop on browser listening to DOM events, the node event loop is constantly
listening to incoming http or tcp requests, or timers, or events generated by the node application itself.
Node is non-blocking (does not wait for the events to complete before firing new ones) and continues to
start processing events as they arrive.

Node Conventions for Writing Asynchronous Code
Typical approach:
var conn = getDbConnection(connectionString); 
var stmt = conn.createStatement();
var results = stmt.executeQuery(sqlQuery); 
for (var i=0; i<results.length; i++) {
      // print results[i];
}

Asynchronous, “non-blocking” approach:
"Get a connection to the DB, and once you have it, call this function and pass it the connection you just created"
This way, node is free to do other processing while we are waiting for the connection to establish.
getDbConnection(connectionString, function(err, conn) { 	// callback
	conn.createStatement(function(err, stmt) {				// callback
		var results = stmt.executeQuery(sqlQuery); 
		results.on(‘row’, function(result) {	// results is an EventEmitter obj capable of emitting events when
    		// print result						// each row of the query becomes available.  more on this later.
    	});
	}); 
});

Example:
var maxTime = 1000;

// If input is even, double it
// If input is odd, error
// (call takes random amount of time < 1s)
var evenDoubler = function(v, callback) {
    var waitTime = Math.floor(Math.random()*(maxTime+1));
    if (v%2) {
        setTimeout(function() {
            callback(new Error("Odd input"));
        }, waitTime);
    } else {
        setTimeout(function() {
            callback(null, v*2, waitTime);
        }, waitTime);
    }
};

var count = 0;

for (var i = 0; i<10; i++) {
    console.log("Calling evenDoubler for value: " + i);
    evenDoubler(i, function(err, results, time) {
        if (err) {
            console.log("ERROR: " + err.message);
        } else {
            console.log("The results are: " + results + " (" + time + " ms)");
        }
        if (++count === 10) {
            console.log("Done!");	// since we know we've spun up 10 callbacks, this check ensures that
        }							// at this point all the callbacks have returned
    });
};

console.log("-----");


////////////////////////////
Module 2 - Modules, require(), and NPM(node packaged modules)

Using modules in your app:
var foo = require(‘foo’);
var Bar = require(‘bar’);	// note camel case convention for exported objects
var justOne = require(‘largeModule’).justOne;		// can require one specific function from a module

var f = 2 + foo.alpha;		// can export variables
var b = foo.beta() * 3;		// and functions
var bar = new Bar();
console.log(justOne());

3 most common sources of Node modules:
1) Built-in Modules
-Come pre-packaged with Node
-Are require()’d with a simple string identifier: var fs = require(‘fs’);
-A sample of built-in modules include: fs, http, crypto, os

2) Your Project files
-Each .js file is its own module
-A great way to modularize your application’s code
-Each file is require()’d with file system-like semantics:
	-var data = require(‘./data’); 		// data.js in the same directory.  note: drop .js extension
	-var foo = require(‘./other/foo’); 	// foo.js in the ‘other’ subdirectory
	-var bar = require(‘../lib/bar’);
-Single variable require() still valid:
	var justOne = require(‘./data’).justOne;

Variables are marked for export via “module.exports”
one.js
var count = 2;
var doIt = function(i, callback) {
	// do something, invoke callback
}
module.exports.doIt = doIt;
module.exports.foo = ‘bar’;

two.js
var one = require(‘./one’);
one.doIt(23, function (err, result) {
  console.log(result);
}
console.log(one.foo);

3) Third Party Modules via Node Package Manager (NPM) registry
-Installed via “npm install module_name” into “node_modules” folder
-Are require()’d via simple string identifiers, similar to built-ins: 
	var request = require(‘request’);
-Can require() individual files from within a module, but be careful!: 
	var BlobResult = require(‘azure/lib/services/blob/models/blobresult’);
-Some modules provide command line utilities as well, and may have features needed by multiple applications,
	can install these modules in the global scope: “npm install –g module_name”
	Examples include: express, mocha, azure-cli


Creating & publishing your own modules:
To do so, need package.json in the project root dir.
package.json describes your app modules to npm.
{
  “name” : “coolstuff”,   // required
  “version” : “0.0.1”,    // required
  “author” : “Paul O’Fallon”,
  “description” : “A cool module!”,
  “keywords” : [“cool”, “awesome”],		// helps others find your module on npm website
  “repository”: {
    “type” : “git”,
    “url” : “https://github.com/pofallon/coolstuff.git” },
  “dependencies” : {					// dependencies that will automatically download and install
    “underscore” : “1.4.x”,
    “request” : “>=2.1.0”,
  },
  “main” : “lib/cool.js”				// defines entry point of module (what is executed when someone requires your module)
}
-“npm publish .” (from within project root)
-“npm install module_name” (from an empty directory) – verify that it actually works!


////////////////////////////
Events and Streams

